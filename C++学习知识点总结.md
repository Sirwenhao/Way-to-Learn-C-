## C++学习知识点总结：

### 初识C++

#### 1、C++单行注释与多行注释

![image-20210613104730743](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210613104730743.png)

```
多行注释快捷键：control+k+c
```

#### 2、变量

**作用**：给一段指定的内存空间取名，方便对数据进行存取

**语法**：数据类型  变量名 = 初始值；如：

```
int a = 10
```

#### 3、常量

**作用：**用于记录程序中不可更改的数据

C++定义常量的两种方式：

- #define宏常量：

  ```
  #define 常量名 常量值
  --通常在文件上方定义（反映在程序中就是定义在int main()之前），表示一个常量
  
  ```

  

- const修饰的变量：

  ```
  const 数据类型 常量名 = 常量值
  --通常在变量定义前加关键字const，修饰改变量为常量，不可修改
  ```

#### 4、关键字

**C++预留的用于作为标识符的单词，在定义变量或者常量的时候不能使用**

### 数据类型

#### 1、标识符的命名规则

即在C++中规定的给（常量或者是标量）进行命名的规则：

- 标识符不能是关键字
- 标识符只能由数字、字母、下划线_组成，斜线啊反斜线之类的都是违法标识符
- ==第一个字符必须是字母或下划线_==，也就是说不能是数字呗，好像和Python一毛一样
- 在标识符中，字母大小写是有区分的
- 建议：在给变量起名时，最好能做到见名知意

#### 2、数据类型：

C++规定在创建一个变量或者常量时，必须制定出其相应的数据类型，这样便于计算机==给变量或者常量分配相应的内存==，在计算机中对数据进行空间分配时，既不能分配过大的内存空间也不能分配过小的内存空间，太大资源浪费，太小存不下。因此，数据类型定义的核心任务就是给变量分配==合适的内存空间==。

##### 2.1、整型：即==整数类型==的数据

在C++中共有四种可以表示整型数据的类型：（长长整型在输入时输的是long long，==两个long中间是有一个空格的==）

| 数据类型            | 占用空间                                        | 取值范围                 |
| ------------------- | ----------------------------------------------- | ------------------------ |
| short(短整型)       | 2字节                                           | $$-2^{15}$$~$$2^{15}-1$$ |
| int(整型)           | 4字节                                           | $$-2^{31}$$~$$2^{31}-1$$ |
| long(长整型)        | Windows为4字节，Linux为4字节(32位)，8字节(64位) | $$-2^{31}$$~$$2^{31}-1$$ |
| long long(长长整型) | 8字节                                           | $$-2^{63}$$~$$2^{63}-1$$ |

##### 2.2、sizeof关键字：

作用：统计数据类型所占内存的大小

- 语法为：

  ```
  sizeof(数据类型 / 变量)  数据类型或变量的意思
  ```

##### 2.3、实型（浮点型）

作用是：用于表示小数

- 浮点型变量分两种：两者的区别在于表示的==有效数字的范围不同==。如3.14包含三位有效数字3、1、4.

  1、单精度浮点型float

  2、双精度浮点型double

| 数据类型 | 占用空间 | 有效数字范围    |
| -------- | -------- | --------------- |
| float    | 4字节    | 7位有效数字     |
| double   | 8字节    | 15~16位有效数字 |

##### 2.4、字符型

作用 ：字符型变量用于显示单个字符

语法为：

```
char ch = 'a';
| 注意1：字符变量使用单引号''括起来
| 注意2：单引号内只能有一个字符
```

- C和C++中字符型变量只占用一个字节
- 字符型变量在存储时并不是把自身放到内存中存储，而是将对应的ASCII码放入到存储单元

##### 2.5、字符串型

作用：用于表示一串字符

语法为：

```
1、C语言风格的字符串：char 变量名[] = "字符串值"
2、C++风格字符串：string 变量名 = "字符串值"
```

注意：C++风格的字符串在使用时必须包含==头文件==

```
#include <string>
```

##### 2.6、布尔类型

作用：布尔数据类型代表的是真或者假的值

**bool**类型有两种值：

- true ----- 真（本质是1）
- false ----- 假（本质是0）

布尔类型占==一个字节==大小

##### 2.7、数据输入

作用：用于从键盘获取输入信息

关键字：**cin**

语法：

```
cin >> 变量
```

### 运算符

##### 1、运算符作用：用于执行代码的运算

本部分主要讲解一下运算符：

| 运算符类型 | 作用                                   |
| ---------- | -------------------------------------- |
| 算术运算符 | 用于处理四则运算                       |
| 赋值运算符 | 用于将表达式的值赋给变量               |
| 比较运算符 | 用于表达式的比较，并返回一个真值或假值 |
| 逻辑运算符 | 用于根据表达式的值返回真值或假值       |

##### 2、算术运算符

作用：用于处理四则运算

算术运算符包含以下符号：

| 运算符 | 术语         | 示例            | 结果          |
| ------ | ------------ | --------------- | ------------- |
| +      | 正好         | +3              | 3             |
| -      | 负号         | -3              | -3            |
| +      | 加           | 10 + 5          | 15            |
| -      | 减           | 10 - 5          | 5             |
| *      | 乘           | 10 * 5          | 50            |
| /      | 除           | 10 / 5          | 2             |
| %      | 取模（取余） | 10 % 3          | 1             |
| ++     | 前置递增     | a = 2; b = ++a; | a = 3; b = 3  |
| ++     | 后置递增     | a = 2; b = a++  | a = 3; b = 2; |
| --     | 前置递减     | a = 2; b = --a; | a = 1; b = 1; |
| --     | 后置递减     | a = 2; b = a--; | a = 1; b = 2; |

##### 3、赋值运算符

作用：用于将表达式的值赋给变量

赋值运算符包含以下符号：

| 运算符 | 术语   | 示例          | 结果         |
| ------ | ------ | ------------- | ------------ |
| =      | 赋值   | a = 2;b = 3;  | a = 2;b = 3; |
| +=     | 加等于 | a = 0;a += 2; | a = 2;       |
| -=     | 减等于 | a = 5;a -= 3; | a = 2;       |
| *=     | 乘等于 | a = 2;a *= 2; | a = 4;       |
| /=     | 除等于 | a =4;a /= 2;  | a = 2;       |
| %=     | 模等于 | a =3;a % 2;   | a = 1;       |

##### 4、比较运算符

作用：用于表达式的比较，并返回一个真值或者假值

比较运算符有以下符号：

| 运算符 | 术语     | 示例   | 结果 |
| ------ | -------- | ------ | ---- |
| ==     | 相等于   | 4 == 3 | 0    |
| !=     | 不等于   | 4 != 3 | 1    |
| <      | 大于     | 4 < 3  | 0    |
| >      | 小于     | 4 > 3  | 1    |
| <=     | 小于等于 | 4 <= 3 | 0    |
| >=     | 大于等于 | 4 >= 1 | 1    |

##### 5、逻辑运算符

根据表达式的值返回真值或假值

逻辑运算符有以下符号：

| 运算符 | 术语   | 示例         | 结果                                                     |
| ------ | ------ | ------------ | -------------------------------------------------------- |
| ！     | 非     | !a           | 如果a为假，则!a为真；如果a为真，则!a为假。               |
| &&     | 与     | a && b       | 如果a和b都为真，则结果为真，否则为假。                   |
| \|\|   | ==或== | ==a \|\| b== | 如果a和b有一个为真，则结果为真，二者都为假时，结果为假。 |

##### 程序流程结构

C/C++支持三种最基本的程序运行结构：==顺序结构、选择结构、循环结构==

- 顺序结构：程序顺序执行，不跳转
- 选择结构：根据条件是否满足，有选择地执行相应功能
- 循环结构：依据条件是否满足，循环多次执行某段代码

##### 4.1选择结构

###### 4.1.1 if语句

作用：执行满足条件的语句 

**if**语句的三种形式

- 单行格式**if**语句
- 多行格式**if**语句
- 多条件**if**语句

1.单行格式的**if**语句：

```
if(条件){满足条件时，要执行的语句}
```

2.多行格式**if**语句

```
if（条件）{条件满足执行的语句}else{条件不满足执行的语句}；
```

3.多条件**if**语句

```
if(条件1)（条件1满足时执行的语句）else if(条件2)（条件2满足时执行的语句）...else(都不满足时执行的语句)
```

![image-20210623103241855](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210623103241855.png)

嵌套if语句：在if语句中可以嵌套使用if语句，做更细致的条件判断

案例需求：

- 提示一用户输入高考分数，根据分数做如下判断

- 分数如果大于600分视为考上一本，大于500分视为考上二本，大于400分视为考上三本，其余视为未考上本科

- 在一本分数中，大于700分，考入清华，大于650分，考入北大，大于600分，考入人大


##### 三目运算符

作用：通过三目运算符实现简单的判断

语法：

```
表达式1？表达式2：表达式3
```

==解释：如果表达式1的值为真，执行表达式2，并返回表达式2的结果；如果表达式1的值为假，执行表达式3，并返回表达式3的结果。==

##### switch语句

作用：执行多条件分支语句

语法：

```
switch（表达式）
{

	case结果1：执行语句；break；
	
	case结果2；执行语句；break;
	
	...
	
	default：执行语句；break；

}
```

根据表达式的结果选择执行那个分支，结果为1就选case结果1，结果为2就选case结果2，依次类推，如果都没有就选default。

| 注意1：switch语句中==表达式类型只能是整型或者字符型==

| 注意2：case里面如果没有==break==，那么程序会一直向下执行

| 总结：与if语句相比，对于多条件判断时，switch结构清晰，执行效率高，缺点是switch语句不能判断区间

##### 4.2循环结构

###### 4.2.1 while循环语句

作用：满足循环条件的情况下，执行循环体

语法：

```
while（循环条件）{循环语句}
```

解释：只要循环的条件结果为真，就执行循环语句

![image-20210626103031853](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210626103031853.png)

注意：while后面的括号中填入的是满足的条件，另外一定要避免死循环的出现。

while循环练习题

![image-20210626105008475](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210626105008475.png)

###### 4.4.2 do...while循环语句

作用：满足循环条件，执行循环条件

语法：

```
do{循环语句} while （循环条件）；
```

注意：与while的区别在于do...while会先执行一次循环语句，在判断循环条件

![image-20210627073257457](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210627073257457.png)

练习题水仙花数

![image-20210627080735434](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210627080735434.png)

在C++中整数和整数之间除法，返回值也是==整数==无论是否整除

###### 4.2.3 for循环

作用：满足循环条件，执行循环语句

语法：

```
fo（起始表达式；条件表达式；结尾表达式）{ 循环语句； }
```

for循环执行步骤示意图：

![image-20210628150900978](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210628150900978.png)

| 注意：for循环中的表达式要用分号进行分割

| 总结：while，do…while，for都是开发中常用的循环语句，for循环结构比较清晰

练习案例：敲桌子。从1开始数到数字100，如果数字个位含有7，或者十位数字含有7，或者是7的倍数，我们打印敲桌子，其余数字直接打印输出。

###### 4.2.4 嵌套循环

作用：在循环体中在嵌套一层循环，解决一些实际问题

练习案例：打印星图

练习案例：九九乘法表，要求：利用嵌套循环实现

- 首先：共有九行九列数据，且乘法表中乘号左侧数字均相同为列数，乘号右侧数字逐渐增加为行数。列数*行数为结果。
- 其次：通过列数小于等于当前行数这一特点，可以控制表中空白的那一半

![image-20210629151045540](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210629151045540.png)

##### 4.3 跳转语句

###### 4.3.1 break语句

作用：用于跳出==循环结构==或者==选择结构==

break使用的时机：

- 出现在switch条件语句中，作用是终止case并跳出switch
- 出现在循环语句中，作用是跳出当前的循环语句
- 出现在嵌套循环中，跳出最近的内层循环

###### 4.3.2 continue语句

作用：再循环语句中，==跳过本次循环中余下未执行的语句==，继续==执行下一次循环==

案例：输出奇数偶数

###### 4.3.3 goto语句

作用：可以跳过某些语句进而执行其他语句

语法：

```
goto 标记;
```

	int main()
	{
		//goto语句
	
	cout << "1、XXXX" << endl;
	
	cout << "2、XXXX" << endl;
	
	goto FLAG;  //goto 后面定义的标记之后是分号
	
	cout << "3、XXXX" << endl;
	
	cout << "4、XXXX" << endl;
	
	FLAG:  //标记后面是冒号
	
	cout << "5、XXXX" << endl;
	
	system("pause");
	
	return 0;
	
	}

#### 5、数组

##### 5.1 概述

数组：即一个数据集和，其中存放了许多相同类型的元素

特点1：数组中的每个数据元素都是相同的数据类型

特点2：数组是由==连续的内存位置==组成的，可以通过下标来访问数组中的元素，从0开始的

##### 5.2 一维数组

###### 5.2.1 一维数组的定义方式

一维数组定义的三种方式：

```
1、数据类型  数组名[ 数组长度 ]；
```

```
2、数据类型  数组名[ 数组长度 ] = {值1，值2，…}；
```

```
3、数据类型  数组名[ ] = {值1，值2，…}；
```

###### 5.2.2 一维数组数组名

一维数组数组名的用途：

1. 可以统计整个数组在内存中的长度，使用**sizeof(arr)**命令
2. 可以获取数组在内存中的首地址，使用**cout << arr[0] << endl**
3. **sizeof(arr[0])**可以获取到数组**arr**中第一个元素所占的内存空间大小，元素个数可以通过**sizeof(arr)/size(arr[0])**

练习案例1：五支小猪称体重

案例分析：在一个数组中记录了五只小猪的体重，如：**int arr[5] = {300,350,200,400,250}**

找出并打印出最重的小猪的体重



练习案例2：数组元素逆置

案例描述：请声明一个5个元素的数组，并且将元素逆置。

（如原数组元素为：1，3，2，5，4；逆置后输出的结果为：4，5，2，3，1）

思考过程见下图

![image-20210703161211783](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210703161211783.png)

###### 5.2.3 冒泡排序

作用：最常用的排序算法，对数组内元素进行排序

1、比较相邻的元素。如果第一个比第二个大，就交换位置（这种是从小到大排列）。

2、对每一对相邻元素做同样的工作，执行完毕后，找到第一个最大值。

3、重复执行上述步骤，每次比较次数减一，直至结束。

解题思路：

![image-20210703212650230](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210703212650230.png)

##### 5.3 二维数组

二维数组相较于一维数组，即在其原有的维度上拓展了一个新的维度。

###### 5.3.1 二维数组定义的四种方式：

```
1、数据类型 数组名[ 行数 ][ 列数 ];
```

```
2、数据类型 数组名[ 行数 ][ 列数 ] = { { 数据1,数据2 },{ 数据3,数据4 } };
```

```
3、数据类型 数组名[ 行数 ][ 列数 ] = { 数据1,数据2,数据3,数据4 };
```

```
4、数据类型 数组名[ ][ 列数 ] = { 数据1，数据2，数据3，数据4 };
```

建议：以上四种定义方式，第二种较为直观，代码可读性较强

###### 5.3.2 二维数组数组名

二维数组名称的两种用途：

- 查看二维数组所占==内存空间==
- 获取二维数组==首地址==

###### 5.3.3 二维数组应用案例

考试成绩统计：

案例描述：有三名同学（张三，李四，王五），在一次考试中的成绩分别如下表，请分别输出三名同学的总成绩

|      | 语文 | 数学 | 英语 |
| :--: | :--: | :--: | :--: |
| 张三 | 100  | 100  | 100  |
| 李四 |  90  |  50  | 100  |
| 王五 |  60  |  70  |  80  |

#### 6、 函数的定义

##### 6.1 概述

作用：将一段代码封装起来，减少重复代码。将一个大的代码分为若干个程序块，每个模块实现特定的功能。

##### 6.2 函数的定义

函数的定义一般主要有5个步骤：

1、返回值类型

2、函数名

3、参数列表

4、函数体语句

5、return表达式

**语法：**

```
返回值类型 函数名 （参数列表）
{
	函数体语句
	
	return表达式
}
```

##### 6.3 函数的调用

功能：使用定义好的函数结构体

语法：

```
函数名（参数）
```

注意：函数定义时传入的参数称为形参，函数调用时传入的参数称为实参

#####  6.4 值传递

- 所谓值传递，即在==函数调用时==实参将数值传入给形参

- ==值传递==时，若==形参==发生改变，并不会影响实参

  值传递的解释：

![image-20210707093420674](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210707093420674.png)

在此段程序执行期间，a和b的值均未发生改变，对应的变量都有为其开辟的内存地址以及相应的值。

##### 6.5 函数的常见样式

函数常见样式有四种：

- 有参无返
- 无参无返
- 无参有返
- 有参有返

##### 6.6 函数声明

作用：告诉编译器函数名称以及如何调用函数，函数的实际主体可以单独定义。

注意：函数的声明可以有多次，函数的定义只能有一次

##### 6.7 函数的分文件编写

作用：让代码结构更加清晰，因为目前我们所写的代码都在一个文件夹中，如果代码过长就需要不停的返回去找，过于浪费时间。

函数份文件编写一般有四个步骤：

- 创建后缀名为**.h**的头文件
- 创建后缀名为**.cpp**的源文件
- 在==头文件==中写函数的==声明==
- 在==源文件==中写函数的==定义==

#### 7、指针

##### 7.1 指针的基本概念

**指针的作用**：可以通过指针间接**访问内存**

- 内存编号是从0开始记录的，一般用十六进制数字表示
- 可以==利用指针变量保存地址==，指针就是一个==变量==，指针中存储的就是一个==地址==

##### 7.2 指针变量的定义和使用

指针变量定义语法：

```
数据类型 * 指针变量名;
```

##### 7.3 指针所占内存空间

指针也是一种数据类型，那么指针这种数据类型占多少内存空间呢？在32位操作系统中，指针占用四个字节空间；在64位操作系统中，指针占用八个字节空间。

##### 7.4 空指针和野指针

**空指针**：指针变量指向内存中==编号为0的空间==

**用途**：==初始化==指针变量（当一开始指针不知指向何处时，可将其指向此处）

**注意**：空指针指向的内存是==不可以访问的==（0-255这块内存是系统占用的不能被指针所访问）

**野指针**：指向非法的内存空间

##### 7.5 *const*修饰指针

**const**修饰指针有三种情况：

1. **const**修饰指针  --- 常量指针
2. **const**修饰常量  --- 指针常量
3. **const**即修饰指针，又修饰常量

第一种：**const**修饰指针中，==指针的指向可以修改（即指针指向的位置是可以改变的，但是指针指向的原始位置中的值是不能修改的）==，但==指针所存内容不可修改==。语法为：

```
const int * p = &a
```

![image-20210711085844710](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210711085844710.png)

如上图：a，b均为一个值为10的变量，地址不同。**int * p = &a**表示**p**这个指针指向的就是**a**的地址**0x0011**，*** p**即表示这个地址（**0x0011**）中存储的内容10.

用**const**修饰常量指针（即指针是一个常量，比如此例中地址都是确定的），这种情况下==指针的指向（即指针的值）可以修改==，但==指针指向的位置中内容不能修改==。

第二种：**const**修饰常量中，==指针的指向（即指针指向的那个地址不能修改）不可修改==，==指针指向的内容可以修改==。**const**修饰常量语法为：

```
int * const p = &a
```

![image-20210711091247809](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210711091247809.png)

如上图：a，b均为一个值为10的变量，地址不同。**int * p = &a**表示**p**这个指针指向的就是**a**的地址**0x0011**，*** p**即表示这个地址（**0x0011**）中存储的内容10.

**p**本是变量，**const**修饰之后，**const p**视为常量，因此得名指针常量，这种情况下==指针的指向（即原指针地址）不可修改==，==指针指向的内容（即原指针中所存的内容）可以修改==。

第三种：**const**即修饰指针，又修饰常量，此种情况中==指针的指向和指针指向的值都不可以修改==

![image-20210711092249940](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210711092249940.png)

如上图，即修饰指针又修饰变量的语法为：

```
const int * const p = &a
```

**Tips：**记忆方法

1、记忆常量指针还是指针常量，只需要看**const**和*****以及**p**的相对位置。**const**译成中文是常量的意思，若**const**后面紧跟的是指针*****就表示是常量指针，若*****在前，指针**const**在后则称为指针常量。即观察*****的位置和**const**的位置。

2、记忆那个可以修改

如：**const**后面是指针p，已被**const**限定所以不能修改

```
int * const p = &a
```

如：const后面紧跟的是*****，则***p**已被限定不能修改

```
const int * p = &a
```

##### 7.6 指针和数组

作用：利用指针访问数组中元素，目的是利用指针访问数组中的每一个元素

##### 7.7 指针和函数

作用：利用指针做函数的参数，可以修改实参的值(参考上述值传递部分，简单推理一下，理解一下两者的区别)

![image-20210712095335843](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210712095335843.png)

注意：

- 值传递不会改变实参
- 地址传递会改变实参

##### 7.8 指针、数组、函数

案例描述：封装一个函数，使用冒泡排序，实现对整型数组的升序排序

例如数组：

```
int arr[10]  =  {4,3,6,9,1,2,10,8,7,5}
```

此程序的一些核心点：

- 如何把一个数组传递到一个函数中
- 第二点冒泡排序熟练使用
- 最好传入数组的长度

#### 8、结构体

##### 8.1 结构体的基本概念

结构体属于用户自定义的数据类型，允许用户存储不同的数据类型（就是说学了结构体之后，除了C++自定义的数据类型，自己也可以创造新的数据类型）

##### 8.2 结构体定义和使用

语法：

```
struct 结构体名 {结构体成员列表}；
```

通过结构体创建变量的方式有三种：

- **struct**结构体名 变量名
- **struct**结构体名 变量名 = {成员1值，成员2值...}
- 定义结构体时顺便创建变量

##### 8.3 结构体数组

作用：将自定义的结构体放入到数组中方便维护

语法：

```
struct 结构体名 数组名[元素个数] = { {}，{}，...，{} }
```

##### 8.4 结构体指针

作用：通过指针访问结构体中的成员

- 利用操作符 -> 可以通过结构体指针访问结构体属性

##### 8.5 结构体嵌套结构体

作用：结构体中的成员可以是另一个结构体

比如：每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体。即在一个结构体中，将另一个结构体当作此结构体中的一个成员。

![image-20210714155219624](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210714155219624.png)

##### 8.6 结构体做函数参数

作用：将结构体作为参数向函数中传递

传递方式：两种

- 值传递
- 地址传递

##### 8.7 结构体中的const的使用场景

**作用：**用**const**来防止误操作，见例55

##### 8.8 结构体的案例

8.8.1 案例1

**案例描述**：学校正在做毕设项目，每个老师带领五个学生，总共有三名老师，需求如下：设计老师和学生的结构体，其中在老师的结构体中，有老师姓名和存放五个学生的数组作为成员，学生的成员有姓名、考试分数，创建数组存放3明老师，通过函数给每个老师即所带的学生赋值，最终打印出老师的数据以及老师所带的学生数据。

8.8.2 案例2

案例描述：设计一个英雄的结构体，包括成员的姓名年龄，性别；创建结构体数组，数组中存放五名英雄，通过冒泡排序法，将英雄按照年龄升序进行排序，最终打印排序后的结果。

### C++核心编程

本阶段主要针对C++==面向对象==编程技术做详细讲解，探讨C++中的核心与精髓。

#### 1 、内存分区模型

C++程序在执行时，将内存大方向划分为**四个区域**：

- 代码区：存放函数体的二进制代码，由操作系统进行管理
- 全局区：存放全局变量和静态变量以及常量
- 栈区：由编译器自动分配释放，存放函数的参数值，局部变量等
- 堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收

内存四区的意思：

不同区域存放的数据，赋予不同的生命周期，给我们的更大的变成灵活性。

##### 1.1 程序运行前

在程序编译后，生成了可执行程序，未执行该程序前分为两个区域

代码区：

- 存放CPU执行的机器指令
- 代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可
- 代码区是只读的，使其只读的原因是防止程序以外的修改了它的指令

全局区：

- 全局变量和静态变量存放在此
- 全局区还包含了常量区，字符串常量和其他常量(这个其他常量专指用const修饰的变量)也存放在此
- 该区域的数据子程序结束后由操作系统释放

![image-20210807204539015](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210807204539015.png)

总结：

- C++中在程序运行前分为全局区和代码区
- 代码区特点是共享和只读
- 全局区中存放的全局变量、静态变量、常量
- 常量区中存放const修饰的全局常量和字符串常量

##### 1.2 程序运行后

栈区：

- 由编译器自动分配释放，存放函数的参数值，局部变量等

- 注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放

堆区：

- 由程序员分配释放，若程序员不释放，程序结束时由操作系统回收
- 在C++中主要利用new在对去开辟内存

注意：

- 堆区数据由程序员管理开辟和释放
- 堆区数据利用new关键字进行开辟内存

##### 1.3 new操作符

- C++利用new操作符在堆区开辟数据
- 堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符**delete**

语法：

```
new 数据类型
```

利用new创建的数据，会返回该数据对应的类型的指针

#### 2、引用

##### 2.1 引用的基本使用

作用：给变量起别名

语法：

```
数据类型 &别名 = 原名
```

注意：

- 数据类型与原变量的数据类型必须相同

![image-20210810210542400](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210810210542400.png)

##### 2.2 引用注意事项

- 引用必须初始化
- 引用在初始化后，不可以改变

![image-20210811194754384](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210811194754384.png)

##### 2.3 引用做函数参数

**作用**：函数传参时，可以利用引用的技术让形参修饰实参

**优点**：可以简化指针修改实参

总结：形参修饰实参的两种方法，实例见62引用做函数参数示例

- 地址传递
- 引用传递

