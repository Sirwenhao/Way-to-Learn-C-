## C++学习知识点总结：

### 初识C++

#### 1、C++单行注释与多行注释

![image-20210613104730743](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210613104730743.png)

```
多行注释快捷键：control+k+c
```

#### 2、变量

**作用**：给一段指定的内存空间取名，方便对数据进行存取

**语法**：数据类型  变量名 = 初始值；如：

```
int a = 10
```

#### 3、常量

**作用：**用于记录程序中不可更改的数据

C++定义常量的两种方式：

- #define宏常量：

  ```
  #define 常量名 常量值
  --通常在文件上方定义（反映在程序中就是定义在int main()之前），表示一个常量
  
  ```

  

- const修饰的变量：

  ```
  const 数据类型 常量名 = 常量值
  --通常在变量定义前加关键字const，修饰改变量为常量，不可修改
  ```

#### 4、关键字

**C++预留的用于作为标识符的单词，在定义变量或者常量的时候不能使用**

### 数据类型

#### 1、标识符的命名规则

即在C++中规定的给（常量或者是标量）进行命名的规则：

- 标识符不能是关键字
- 标识符只能由数字、字母、下划线_组成，斜线啊反斜线之类的都是违法标识符
- ==第一个字符必须是字母或下划线_==，也就是说不能是数字呗，好像和Python一毛一样
- 在标识符中，字母大小写是有区分的
- 建议：在给变量起名时，最好能做到见名知意

#### 2、数据类型：

C++规定在创建一个变量或者常量时，必须制定出其相应的数据类型，这样便于计算机==给变量或者常量分配相应的内存==，在计算机中对数据进行空间分配时，既不能分配过大的内存空间也不能分配过小的内存空间，太大资源浪费，太小存不下。因此，数据类型定义的核心任务就是给变量分配==合适的内存空间==。

##### 2.1、整型：即==整数类型==的数据

在C++中共有四种可以表示整型数据的类型：（长长整型在输入时输的是long long，==两个long中间是有一个空格的==）

| 数据类型            | 占用空间                                        | 取值范围                 |
| ------------------- | ----------------------------------------------- | ------------------------ |
| short(短整型)       | 2字节                                           | $$-2^{15}$$~$$2^{15}-1$$ |
| int(整型)           | 4字节                                           | $$-2^{31}$$~$$2^{31}-1$$ |
| long(长整型)        | Windows为4字节，Linux为4字节(32位)，8字节(64位) | $$-2^{31}$$~$$2^{31}-1$$ |
| long long(长长整型) | 8字节                                           | $$-2^{63}$$~$$2^{63}-1$$ |

##### 2.2、sizeof关键字：

作用：统计数据类型所占内存的大小

- 语法为：

  ```
  sizeof(数据类型 / 变量)  数据类型或变量的意思
  ```

##### 2.3、实型（浮点型）

作用是：用于表示小数

- 浮点型变量分两种：两者的区别在于表示的==有效数字的范围不同==。如3.14包含三位有效数字3、1、4.

  1、单精度浮点型float

  2、双精度浮点型double

| 数据类型 | 占用空间 | 有效数字范围    |
| -------- | -------- | --------------- |
| float    | 4字节    | 7位有效数字     |
| double   | 8字节    | 15~16位有效数字 |

##### 2.4、字符型

作用 ：字符型变量用于显示单个字符

语法为：

```
char ch = 'a';
| 注意1：字符变量使用单引号''括起来
| 注意2：单引号内只能有一个字符
```

- C和C++中字符型变量只占用一个字节
- 字符型变量在存储时并不是把自身放到内存中存储，而是将对应的ASCII码放入到存储单元

##### 2.5、字符串型

作用：用于表示一串字符

语法为：

```
1、C语言风格的字符串：char 变量名[] = "字符串值"
2、C++风格字符串：string 变量名 = "字符串值"
```

注意：C++风格的字符串在使用时必须包含==头文件==

```
#include <string>
```

##### 2.6、布尔类型

作用：布尔数据类型代表的是真或者假的值

**bool**类型有两种值：

- true ----- 真（本质是1）
- false ----- 假（本质是0）

布尔类型占==一个字节==大小

##### 2.7、数据输入

作用：用于从键盘获取输入信息

关键字：**cin**

语法：

```
cin >> 变量
```

### 运算符

##### 1、运算符作用：用于执行代码的运算

本部分主要讲解一下运算符：

| 运算符类型 | 作用                                   |
| ---------- | -------------------------------------- |
| 算术运算符 | 用于处理四则运算                       |
| 赋值运算符 | 用于将表达式的值赋给变量               |
| 比较运算符 | 用于表达式的比较，并返回一个真值或假值 |
| 逻辑运算符 | 用于根据表达式的值返回真值或假值       |

##### 2、算术运算符

作用：用于处理四则运算

算术运算符包含以下符号：

| 运算符 | 术语         | 示例            | 结果          |
| ------ | ------------ | --------------- | ------------- |
| +      | 正好         | +3              | 3             |
| -      | 负号         | -3              | -3            |
| +      | 加           | 10 + 5          | 15            |
| -      | 减           | 10 - 5          | 5             |
| *      | 乘           | 10 * 5          | 50            |
| /      | 除           | 10 / 5          | 2             |
| %      | 取模（取余） | 10 % 3          | 1             |
| ++     | 前置递增     | a = 2; b = ++a; | a = 3; b = 3  |
| ++     | 后置递增     | a = 2; b = a++  | a = 3; b = 2; |
| --     | 前置递减     | a = 2; b = --a; | a = 1; b = 1; |
| --     | 后置递减     | a = 2; b = a--; | a = 1; b = 2; |

##### 3、赋值运算符

作用：用于将表达式的值赋给变量

赋值运算符包含以下符号：

| 运算符 | 术语   | 示例          | 结果         |
| ------ | ------ | ------------- | ------------ |
| =      | 赋值   | a = 2;b = 3;  | a = 2;b = 3; |
| +=     | 加等于 | a = 0;a += 2; | a = 2;       |
| -=     | 减等于 | a = 5;a -= 3; | a = 2;       |
| *=     | 乘等于 | a = 2;a *= 2; | a = 4;       |
| /=     | 除等于 | a =4;a /= 2;  | a = 2;       |
| %=     | 模等于 | a =3;a % 2;   | a = 1;       |

##### 4、比较运算符

作用：用于表达式的比较，并返回一个真值或者假值

比较运算符有以下符号：

| 运算符 | 术语     | 示例   | 结果 |
| ------ | -------- | ------ | ---- |
| ==     | 相等于   | 4 == 3 | 0    |
| !=     | 不等于   | 4 != 3 | 1    |
| <      | 大于     | 4 < 3  | 0    |
| >      | 小于     | 4 > 3  | 1    |
| <=     | 小于等于 | 4 <= 3 | 0    |
| >=     | 大于等于 | 4 >= 1 | 1    |

##### 5、逻辑运算符

根据表达式的值返回真值或假值

逻辑运算符有以下符号：

| 运算符 | 术语   | 示例         | 结果                                                     |
| ------ | ------ | ------------ | -------------------------------------------------------- |
| ！     | 非     | !a           | 如果a为假，则!a为真；如果a为真，则!a为假。               |
| &&     | 与     | a && b       | 如果a和b都为真，则结果为真，否则为假。                   |
| \|\|   | ==或== | ==a \|\| b== | 如果a和b有一个为真，则结果为真，二者都为假时，结果为假。 |

##### 程序流程结构

C/C++支持三种最基本的程序运行结构：==顺序结构、选择结构、循环结构==

- 顺序结构：程序顺序执行，不跳转
- 选择结构：根据条件是否满足，有选择地执行相应功能
- 循环结构：依据条件是否满足，循环多次执行某段代码

##### 4.1选择结构

###### 4.1.1 if语句

作用：执行满足条件的语句 

**if**语句的三种形式

- 单行格式**if**语句
- 多行格式**if**语句
- 多条件**if**语句

1.单行格式的**if**语句：

```
if(条件){满足条件时，要执行的语句}
```

2.多行格式**if**语句

```
if（条件）{条件满足执行的语句}else{条件不满足执行的语句}；
```

3.多条件**if**语句

```
if(条件1)（条件1满足时执行的语句）else if(条件2)（条件2满足时执行的语句）...else(都不满足时执行的语句)
```

![image-20210623103241855](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210623103241855.png)

嵌套if语句：在if语句中可以嵌套使用if语句，做更细致的条件判断

案例需求：

- 提示一用户输入高考分数，根据分数做如下判断

- 分数如果大于600分视为考上一本，大于500分视为考上二本，大于400分视为考上三本，其余视为未考上本科

- 在一本分数中，大于700分，考入清华，大于650分，考入北大，大于600分，考入人大


##### 三目运算符

作用：通过三目运算符实现简单的判断

语法：

```
表达式1？表达式2：表达式3
```

==解释：如果表达式1的值为真，执行表达式2，并返回表达式2的结果；如果表达式1的值为假，执行表达式3，并返回表达式3的结果。==

##### switch语句

作用：执行多条件分支语句

语法：

```
switch（表达式）
{

	case结果1：执行语句；break；
	
	case结果2；执行语句；break;
	
	...
	
	default：执行语句；break；

}
```

根据表达式的结果选择执行那个分支，结果为1就选case结果1，结果为2就选case结果2，依次类推，如果都没有就选default。

| 注意1：switch语句中==表达式类型只能是整型或者字符型==

| 注意2：case里面如果没有==break==，那么程序会一直向下执行

| 总结：与if语句相比，对于多条件判断时，switch结构清晰，执行效率高，缺点是switch语句不能判断区间

##### 4.2循环结构

###### 4.2.1 while循环语句

作用：满足循环条件的情况下，执行循环体

语法：

```
while（循环条件）{循环语句}
```

解释：只要循环的条件结果为真，就执行循环语句

![image-20210626103031853](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210626103031853.png)

注意：while后面的括号中填入的是满足的条件，另外一定要避免死循环的出现。

while循环练习题

![image-20210626105008475](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210626105008475.png)

###### 4.4.2 do...while循环语句

作用：满足循环条件，执行循环条件

语法：

```
do{循环语句} while （循环条件）；
```

注意：与while的区别在于do...while会先执行一次循环语句，在判断循环条件

![image-20210627073257457](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210627073257457.png)

练习题水仙花数

![image-20210627080735434](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210627080735434.png)

在C++中整数和整数之间除法，返回值也是==整数==无论是否整除

###### 4.2.3 for循环

作用：满足循环条件，执行循环语句

语法：

```
fo（起始表达式；条件表达式；结尾表达式）{ 循环语句； }
```

for循环执行步骤示意图：

![image-20210628150900978](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210628150900978.png)

| 注意：for循环中的表达式要用分号进行分割

| 总结：while，do…while，for都是开发中常用的循环语句，for循环结构比较清晰

练习案例：敲桌子。从1开始数到数字100，如果数字个位含有7，或者十位数字含有7，或者是7的倍数，我们打印敲桌子，其余数字直接打印输出。

###### 4.2.4 嵌套循环

作用：在循环体中在嵌套一层循环，解决一些实际问题

练习案例：打印星图

练习案例：九九乘法表，要求：利用嵌套循环实现

- 首先：共有九行九列数据，且乘法表中乘号左侧数字均相同为列数，乘号右侧数字逐渐增加为行数。列数*行数为结果。
- 其次：通过列数小于等于当前行数这一特点，可以控制表中空白的那一半

![image-20210629151045540](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210629151045540.png)

##### 4.3 跳转语句

###### 4.3.1 break语句

作用：用于跳出==循环结构==或者==选择结构==

break使用的时机：

- 出现在switch条件语句中，作用是终止case并跳出switch
- 出现在循环语句中，作用是跳出当前的循环语句
- 出现在嵌套循环中，跳出最近的内层循环

###### 4.3.2 continue语句

作用：再循环语句中，==跳过本次循环中余下未执行的语句==，继续==执行下一次循环==

案例：输出奇数偶数

###### 4.3.3 goto语句

作用：可以跳过某些语句进而执行其他语句

语法：

```
goto 标记;
```

	int main()
	{
		//goto语句
	
	cout << "1、XXXX" << endl;
	
	cout << "2、XXXX" << endl;
	
	goto FLAG;  //goto 后面定义的标记之后是分号
	
	cout << "3、XXXX" << endl;
	
	cout << "4、XXXX" << endl;
	
	FLAG:  //标记后面是冒号
	
	cout << "5、XXXX" << endl;
	
	system("pause");
	
	return 0;
	
	}

#### 5、数组

##### 5.1 概述

数组：即一个数据集和，其中存放了许多相同类型的元素

特点1：数组中的每个数据元素都是相同的数据类型

特点2：数组是由==连续的内存位置==组成的，可以通过下标来访问数组中的元素，从0开始的

##### 5.2 一维数组

###### 5.2.1 一维数组的定义方式

一维数组定义的三种方式：

```
1、数据类型  数组名[ 数组长度 ]；
```

```
2、数据类型  数组名[ 数组长度 ] = {值1，值2，…}；
```

```
3、数据类型  数组名[ ] = {值1，值2，…}；
```

###### 5.2.2 一维数组数组名

一维数组数组名的用途：

1. 可以统计整个数组在内存中的长度，使用**sizeof(arr)**命令
2. 可以获取数组在内存中的首地址，使用**cout << arr[0] << endl**
3. **sizeof(arr[0])**可以获取到数组**arr**中第一个元素所占的内存空间大小，元素个数可以通过**sizeof(arr)/size(arr[0])**

练习案例1：五支小猪称体重

案例分析：在一个数组中记录了五只小猪的体重，如：**int arr[5] = {300,350,200,400,250}**

找出并打印出最重的小猪的体重



练习案例2：数组元素逆置

案例描述：请声明一个5个元素的数组，并且将元素逆置。

（如原数组元素为：1，3，2，5，4；逆置后输出的结果为：4，5，2，3，1）

思考过程见下图

![image-20210703161211783](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210703161211783.png)

###### 5.2.3 冒泡排序

作用：最常用的排序算法，对数组内元素进行排序

1、比较相邻的元素。如果第一个比第二个大，就交换位置（这种是从小到大排列）。

2、对每一对相邻元素做同样的工作，执行完毕后，找到第一个最大值。

3、重复执行上述步骤，每次比较次数减一，直至结束。

解题思路：

![image-20210703212650230](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210703212650230.png)

##### 5.3 二维数组

二维数组相较于一维数组，即在其原有的维度上拓展了一个新的维度。

###### 5.3.1 二维数组定义的四种方式：

```
1、数据类型 数组名[ 行数 ][ 列数 ];
```

```
2、数据类型 数组名[ 行数 ][ 列数 ] = { { 数据1,数据2 },{ 数据3,数据4 } };
```

```
3、数据类型 数组名[ 行数 ][ 列数 ] = { 数据1,数据2,数据3,数据4 };
```

```
4、数据类型 数组名[ ][ 列数 ] = { 数据1，数据2，数据3，数据4 };
```

建议：以上四种定义方式，第二种较为直观，代码可读性较强

###### 5.3.2 二维数组数组名

二维数组名称的两种用途：

- 查看二维数组所占==内存空间==
- 获取二维数组==首地址==

###### 5.3.3 二维数组应用案例

考试成绩统计：

案例描述：有三名同学（张三，李四，王五），在一次考试中的成绩分别如下表，请分别输出三名同学的总成绩

|      | 语文 | 数学 | 英语 |
| :--: | :--: | :--: | :--: |
| 张三 | 100  | 100  | 100  |
| 李四 |  90  |  50  | 100  |
| 王五 |  60  |  70  |  80  |

#### 6、 函数的定义

##### 6.1 概述

作用：将一段代码封装起来，减少重复代码。将一个大的代码分为若干个程序块，每个模块实现特定的功能。

##### 6.2 函数的定义

函数的定义一般主要有5个步骤：

1、返回值类型

2、函数名

3、参数列表

4、函数体语句

5、**return**表达式

**语法：**

```
返回值类型 函数名 （参数列表）
{
	函数体语句;
	
	return表达式;
}
```

##### 6.3 函数的调用

功能：使用定义好的函数结构体

语法：

```
函数名（参数）
```

注意：函数定义时传入的参数称为形参，函数调用时传入的参数称为实参

#####  6.4 值传递

- 所谓值传递，即在==函数调用时==实参将数值传入给形参

- ==值传递==时，若==形参==发生改变，并不会影响实参

  值传递的解释：

![image-20210707093420674](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210707093420674.png)

在此段程序执行期间，a和b的值均未发生改变，对应的变量都有为其开辟的内存地址以及相应的值。

##### 6.5 函数的常见样式

函数常见样式有四种：

- 有参无返
- 无参无返
- 无参有返
- 有参有返

##### 6.6 函数声明

作用：告诉编译器函数名称以及如何调用函数，函数的实际主体可以单独定义。

注意：函数的声明可以有多次，函数的定义只能有一次

##### 6.7 函数的分文件编写

作用：让代码结构更加清晰，因为目前我们所写的代码都在一个文件夹中，如果代码过长就需要不停的返回去找，过于浪费时间。

函数份文件编写一般有四个步骤：

- 创建后缀名为**.h**的头文件
- 创建后缀名为**.cpp**的源文件
- 在==头文件==中写函数的==声明==
- 在==源文件==中写函数的==定义==

#### 7、指针

##### 7.1 指针的基本概念

**指针的作用**：可以通过指针间接**访问内存**

- 内存编号是从0开始记录的，一般用十六进制数字表示
- 可以==利用指针变量保存地址==，指针就是一个==变量==，指针中存储的就是一个==地址==

##### 7.2 指针变量的定义和使用

指针变量定义语法：

```
数据类型 * 指针变量名;
```

##### 7.3 指针所占内存空间

指针也是一种数据类型，那么指针这种数据类型占多少内存空间呢？在32位操作系统中，指针占用==四个字节==空间；在64位操作系统中，指针占用==八个字节==空间。

##### 7.4 空指针和野指针

**空指针**：指针变量指向内存中==编号为0的空间==

**用途**：==初始化==指针变量（当一开始指针不知指向何处时，可将其指向此处）

**注意**：空指针指向的内存是==不可以访问的==（0-255这块内存是系统占用的不能被指针所访问）

**野指针**：指向非法的内存空间

##### 7.5 *const*修饰指针

**const**修饰指针有三种情况：

1. **const**修饰指针  --- 常量指针
2. **const**修饰常量  --- 指针常量
3. **const**即修饰指针，又修饰常量

第一种：**const**修饰指针中，==指针的指向可以修改（即指针指向的位置是可以改变的，但是指针指向的原始位置中的值是不能修改的）==，但==指针所存内容不可修改==。语法为：

```
const int * p = &a
```

![image-20210711085844710](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210711085844710.png)

如上图：a，b均为一个值为10的变量，地址不同。**int * p = &a**表示**p**这个指针指向的就是**a**的地址**0x0011**，*** p**即表示这个地址（**0x0011**）中存储的内容10.

用**const**修饰常量指针（即指针是一个常量，比如此例中地址都是确定的），这种情况下==指针的指向（即指针的值）可以修改==，但==指针指向的位置中内容不能修改==。

第二种：**const**修饰常量中，==指针的指向（即指针指向的那个地址不能修改）不可修改==，==指针指向的内容可以修改==。**const**修饰常量语法为：

```
int * const p = &a
```

![image-20210711091247809](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210711091247809.png)

如上图：a，b均为一个值为10的变量，地址不同。**int * p = &a**表示**p**这个指针指向的就是**a**的地址**0x0011**，*** p**即表示这个地址（**0x0011**）中存储的内容10.

**p**本是变量，**const**修饰之后，**const p**视为常量，因此得名指针常量，这种情况下==指针的指向（即原指针地址）不可修改==，==指针指向的内容（即原指针中所存的内容）可以修改==。

第三种：**const**即修饰指针，又修饰常量，此种情况中==指针的指向和指针指向的值都不可以修改==

![image-20210711092249940](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210711092249940.png)

如上图，即修饰指针又修饰变量的语法为：

```
const int * const p = &a
```

**Tips：**记忆方法

1、记忆常量指针还是指针常量，只需要看**const**和*****以及**p**的相对位置。**const**译成中文是常量的意思，若**const**后面紧跟的是指针*****就表示是常量指针，若*****在前，指针**const**在后则称为指针常量。即观察*****的位置和**const**的位置。

2、记忆那个可以修改

如：**const**后面是指针p，已被**const**限定所以不能修改

```
int * const p = &a
```

如：const后面紧跟的是*****，则***p**已被限定不能修改

```
const int * p = &a
```

##### 7.6 指针和数组

作用：利用指针访问数组中元素，目的是利用指针访问数组中的每一个元素

##### 7.7 指针和函数

作用：利用指针做函数的参数，可以修改实参的值(参考上述值传递部分，简单推理一下，理解一下两者的区别)

![image-20210712095335843](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210712095335843.png)

注意：

- 值传递不会改变实参
- 地址传递会改变实参

##### 7.8 指针、数组、函数

案例描述：封装一个函数，使用冒泡排序，实现对整型数组的升序排序

例如数组：

```
int arr[10]  =  {4,3,6,9,1,2,10,8,7,5}
```

此程序的一些核心点：

- 如何把一个数组传递到一个函数中
- 第二点冒泡排序熟练使用
- 最好传入数组的长度

#### 8、结构体

##### 8.1 结构体的基本概念

结构体属于用户==自定义的数据类型==，允许用户存储不同的数据类型（就是说学了结构体之后，除了C++自定义的数据类型，自己也可以==创造新的数据类型==）

##### 8.2 结构体定义和使用

语法：

```
struct 结构体名 {结构体成员列表}；
```

通过结构体创建变量的方式有三种：

- **struct**  结构体名 变量名
- **struct**  结构体名 变量名 = {成员1值，成员2值...}
- 定义结构体时顺便创建变量

##### 8.3 结构体数组

作用：将自定义的结构体放入到数组中方便维护

语法：

```
struct 结构体名 数组名[元素个数] = { {}，{}，...，{} }
```

##### 8.4 结构体指针

作用：通过指针访问结构体中的成员

- 利用操作符 -> 可以通过结构体指针访问结构体属性

##### 8.5 结构体嵌套结构体

作用：结构体中的成员可以是另一个结构体

比如：每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体。即在一个结构体中，将另一个结构体当作此结构体中的一个成员。

![image-20210714155219624](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210714155219624.png)

##### 8.6 结构体做函数参数

作用：将结构体作为参数向函数中传递

传递方式：两种

- 值传递
- 地址传递

##### 8.7 结构体中的const的使用场景

**作用：**用**const**来防止误操作，见例55

##### 8.8 结构体的案例

8.8.1 案例1

**案例描述**：学校正在做毕设项目，每个老师带领五个学生，总共有三名老师，需求如下：设计老师和学生的结构体，其中在老师的结构体中，有老师姓名和存放五个学生的数组作为成员，学生的成员有姓名、考试分数，创建数组存放3明老师，通过函数给每个老师即所带的学生赋值，最终打印出老师的数据以及老师所带的学生数据。

8.8.2 案例2

案例描述：设计一个英雄的结构体，包括成员的姓名年龄，性别；创建结构体数组，数组中存放五名英雄，通过冒泡排序法，将英雄按照年龄升序进行排序，最终打印排序后的结果。

### C++核心编程

本阶段主要针对C++==面向对象==编程技术做详细讲解，探讨C++中的核心与精髓。

#### 1 内存分区模型

C++程序在执行时，将内存大方向划分为**四个区域**：

- 代码区：存放函数体的二进制代码，由操作系统进行管理
- 全局区：存放==全局变量==和==静态变量==以及==常量==
- 栈区：由编译器自动分配释放，存放==函数的参数值==，==局部变量==等
- 堆区：==由程序员分配和释放==，若程序员不释放，程序结束时由操作系统回收

内存四区的意思：

​		不同区域存放的数据，赋予不同的生命周期，给我们的更大的变成灵活性。

##### 1.1 程序运行前

​		在程序编译后，生成了可执行程序，未执行该程序前分为两个区域

代码区：

- 存放CPU执行的机器指令
- 代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可
- 代码区是只读的，使其只读的原因是防止程序以外的修改了它的指令

全局区：

- 全局变量和静态变量存放在此
- 全局区还包含了常量区，字符串常量和其他常量(这个其他常量专指用const修饰的变量)也存放在此
- 该区域的数据子程序结束后由操作系统释放

![image-20210807204539015](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210807204539015.png)

总结：

- C++中在程序运行前分为全局区和代码区
- 代码区特点是共享和只读
- 全局区中存放的全局变量、静态变量、常量
- 常量区中存放const修饰的全局常量和字符串常量

##### 1.2 程序运行后

栈区：

- 由编译器自动分配释放，存放函数的参数值，局部变量等

- 注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放

堆区：

- 由程序员分配释放，若程序员不释放，程序结束时由操作系统回收
- 在C++中主要利用==new==在堆区开辟内存

注意：

- 堆区数据由程序员管理开辟和释放
- 堆区数据利用==new关键字==进行开辟内存

##### 1.3 new操作符

- C++利用new操作符在堆区开辟数据
- 堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符**delete**

语法：

```
new 数据类型
```

利用new创建的数据，会返回该数据对应的类型的指针

#### 2 引用

##### 2.1 引用的基本使用

作用：给变量起==别名==

语法：

```
数据类型 &别名 = 原名
```

注意：

- ==数据类型==与原变量的数据类型必须==相同==

![image-20210810210542400](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210810210542400.png)

引用之后相当于，两个名字指向的都是同一个位置，若更改b则a也会随之被修改。

##### 2.2 引用注意事项

- 引用必须==初始化==
- 引用在初始化后，不可以改变

![](https://cdn.jsdelivr.net/gh/Sirwenhao/images/C:%5CUsers%5CWH%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images202108181006253.png)

##### 2.3 引用做函数参数（引用起的别名可以和原来的名字相同）

**作用**：函数传参时，可以利用引用的技术让==形参修饰实参==

**优点**：可以简化指针修改实参

总结：形参修饰实参的两种方法，实例见62引用做函数参数示例

- 地址传递
- 引用传递

##### 2.4 引用做函数返回值

作用：引用是可以作为函数的返回值存在的

注意：不要返回==局部变量引用==

用法：函数调用作为左值

##### 2.5 引用的本质

**本质：**引用的本质在C++内部实现是一个==指针常量==。引用一旦初始化之后，就不可以发生改变。

![](https://cdn.jsdelivr.net/gh/Sirwenhao/images/C:%5CUsers%5CWH%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images202108181005563.png)

```
int * const ref = &a
ref指向地址0x0011，由于ref是指针常量，所以ref的指向是固定的只能指定当前的地址编号0x0011不能修改。而指针指向的值是可以修改的，比如此地址中存放的数据10是可以进行修改的。
```

结论：C++推荐用引用结束，因为语法方便，==引用本质是指针常量==，但所有的指针操作编译器都帮我们做了

##### 2.6 常量引用

作用：常量引用主要用来修饰形参，防止误操作

在函数形参列表中，可以加==**const**修饰形参==，防止形参改变实参。因此，在定义函数时，需要考虑一下调用函数之后，函数形参或者实参是否会发生改变，并且是否会影响结果。

#### 3 函数提高

##### 3.1 函数默认参数

在C++中，函数的形参列表中的形参是可以有默认值的。

语法：

```
返回值类型 函数名 （参数 = 默认值）{}
```

##### 3.2 函数占位参数

C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置。在现阶段，函数的占位存在意义不大，但是后面的课程中会用到该技术。

语法：

```
返回值类型 函数名 （数据类型）{}
```

##### 3.3 函数重载

###### 3.3.1 函数重载概述

作用：**函数名相同，提高复用性**

函数重载满足条件：

- 同一个作用域下
- 函数名称相同
- 函数参数**类型不同**或者**个数不同**或者**顺序不同**

###### 3.3.2 函数重载注意事项

- 引用作为重载条件
- 函数重载碰到函数默认参数

------

正式进入C++编程核心中的核心

#### 4 类和对象

C++面向对象的三大特性为：==封装==、==继承==、==多态==

C++认为万事万物皆为对象，对象上有其属性和行为。

例如：

人可以作为对象，属性有姓名、年龄、身高、体重，行为有：走、跑、跳、吃饭、唱歌......

具有相同性质的==对象==，可以抽象为==类==，人属于人类

##### 4.1 封装

###### 4.1.1 封装的意义

封装是C++面向对象三大特性值一，封装的意义：

- 将属性和行为作为一个整体，表现生活中的事物
- 将属性和行为加以权限控制

封装意义一：

在设计类的时候，属性和行为写在一起，表现事物

语法：

```
class 类名{  访问权限：属性 / 行为  }；
```

封装意义二：

类在设计时，可以把属性和行为放在不同的权限下，加以控制

访问权限有三种：

- public          公共权限
- protected     保护权限
- private         私有权限

###### 4.1.2 struct和class的区别

在C++中struct和class的==唯一区别==就在于：==默认的访问权限不同==。区别：

- struct  默认访问权限为==公共==
- class  默认访问权限位==私有==

###### 4.1.3 成员属性设置为私有

优点：

- 将所有==成员属性==设置为==私有==，可以自己控制读写权限
- 对于写权限，我们可以检测数据的有效性

**练习案例1：设计立方体类**

​		设计立方体类（***Cube***）

​		求出立方体的面积和体积

​		分别用全局函数和成员函数判断两个立方体是否相等

**练习案例2：点和圆的关系**

​		设计一个圆形类（***Circle***）和一个点类（***Point***），计算点和圆的关系。此案例中还讲解了如何将一个类分解出多个，分文件编写。

​		此案例两个核心点：

- 在一个类中让另外一个类作为此类的成员
- 如何把一个类拆成不同的文件。如此例中将点类、圆类分别写入两个头文件和***cpp***可执行文件中，然后注意学习下在头文件中应该怎么写，在***cpp***文件中有该怎么写。在头文件中留下所有成员函数的声明和成员属性的声明，在***cpp***文件中要讲清楚是成员函数，并使用如：`Circle::，Point::`等字符加以说明。

##### 4.2 对象的初始化和清理

- 类似于生活中我们所使用电子产品的**出厂设置**，在某一天我们不用的时候也会删除一些自己的信息数据保证安全
- C++中的面向对象来源于生活，每个对象也都会有初始设置以及对象销毁前的是清理数据的设置

###### 4.2.1 构造函数和析构函数

对象的==初始化==和==清理==也是两个非常重要的安全问题

- 一个对象或者变量没有初始状态，对其使用后果是未知
- 同样使用完一个对象或者变量，没有及时清理，也会造成一定的安全问题

因此，C++中引入==构造函数==和==析构函数==解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。对象的初始化和清理工作是编译器强制要我们做的事情，因此如果==我们不提供构造和析构，编译器会提供。编译器提供的构造函数和析构函数是空实现。==空实现是指编译器提供的函数体是空的。

- 构造函数：主要作用在于创建对象时==为对象的成员属性赋值，即初始化类对象的成员数据==，构造函数由编译器自动调用，无需手动调用
- 析构函数：主要作用在于对象==销毁前==系统自动调用，执行一些清理工作

构造函数的语法：`类名(){}`

1. 构造函数，没有返回值也不写void
2. 函数名称与类名==相同==
3. 构造函数可以有==参数==，因此==可以发生重载==
4. 程序在调用对象时候会自动调用构造，无需手动调用，而且只会调用一次

析构函数的语法：`~类名(){}`

1. 析构函数，没有返回值也不写void
2. 函数名称与类名==相同==，在名称前加上==符号~==
3. 析构函数==不可以有参数，因此不可以发生重载==
4. 程序在对象销毁前会自动调用析构，无需手动调用，而且只会调用一次

###### 4.2.2 构造函数的分类及调用

两种分类方式：

- 按参数分为：有参构造和无参构造
- 按类型分为：普通构造和拷贝构造

三种调用方式：

- 括号法
- 显示法
- 隐式转换法

######  4.2.3 拷贝构造函数调用时机

C++中拷贝构造函数调用时机通常有三种情况

- 使用一个已经创建完毕的对象来初始化一个新的对象
- 值传递的方式给函数参数传值
- 以值方式返回局部对象

###### 4.2.4 构造函数调用规则

默认情况下，C++编译器至少给一个类添加3个函数

- 默认构造函数（无参，函数体为空）
- 默认析构函数（无参，函数体为空）
- 默认拷贝构造函数，对属性值进行拷贝

构造函数调用规则如下：

- 如果用户定义有参构造函数，C++不再提供默认无参构造，但是会提供默认拷贝构造
- 如果用户定义拷贝构造函数，C++不会再提供其他构造函数

根据本小节示例，可以总结如下（对应以上调用规则）：

- 如果提供了有参构造函数，则编译器不再提供默认构造函数，但会提供拷贝构造函数
- 如果提供了拷贝构造函数，则编译器不再提供默认构造函数，也不会提供有参构造函数

###### 4.2.5 深拷贝与浅拷贝

​		深浅拷贝是面试经典问题，也是一个常见的坑。浅拷贝：简单的复制拷贝操作。深拷贝，在==堆区==重新申请空间，进行拷贝操作。

![image-20210822195301559](https://cdn.jsdelivr.net/gh/Sirwenhao/images/C:%5CUsers%5CWH%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images202108221953703.png)

- 创建了两个对象`p1`和`p2`，每个对象都包含两种属性，年龄和身高
- 利用编译器提供的拷贝构造函数，做浅拷贝实际上就是逐字节的将对象`p1`的属性拷贝到对象`p2`中
- 当执行析构函数的时候，两个对象都会执行析构。按照栈==先进后出==的规则，后入栈的对象`p2`会被先析构。
- 后入栈的对象`p2`先被析构，堆区上的内存`0x0011`会被释放，等到对象`p1`析构时，此内存又会被析构函数重复操作，重复析构。这就是浅拷贝所带来的问题（==堆区的内存重复释放==），堆区的内存重复释放。
- 堆区内存重复释放的问题，可以由深拷贝来解决。

![image-20210822193758108](https://cdn.jsdelivr.net/gh/Sirwenhao/images/C:%5CUsers%5CWH%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images202108221938180.png)

- 重新在堆区找一块内存地址，这样析构时是对两个地址分别执行，就不会重复释放同一块内存地址了。

###### 4.2.6 初始化列表

**作用：**C++提供了初始化列表语法，用来初始化属性

语法：`构造函数()：属性1(值1)，属性2(值2)...{}`

###### 4.2.7 类对象作为类成员

C++类中的成员可以是另一个类的对象，我们称改成员为对象成员

例如：

```
class A {}
class B
{
	A a;
}
```

B类中有对象A作为成员，A为对象成员。那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？答案是先A，当其它类的对象作为我本类的成员时，那么我创建本类的对象时，他会先构造其他的类的对象

###### 4.2.8 静态成员

静态成员就是在成员变量和成员函数前加关键字==static==，称为静态成员。静态成员可以分为：

- 静态成员变量
  - 所有对象共享同一份数据
  - 在编译阶段分配内存
  - ==类内声明，类外初始化==
- 静态成员函数
  - 所有对象共享同一函数
  - 静态成员函数==只能==访问静态成员变量

![image-20210824213219726](https://cdn.jsdelivr.net/gh/Sirwenhao/images/C:%5CUsers%5CWH%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images202108242132942.png)

##### 4.3 C++对象模型和this指针

###### 4.3.1 成员变量和成员函数分开存储

在C++中，类内的成员变量和成员函数分开存储。==只有非静态成员变量才属于类的对象上==。

###### 4.3.2 `this`指针概念

​		通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的，每一个非静态成员函数只会诞生一份函数实例，而就是说多个同类型的对象会共用一块代码，那么问题是：这一块代码是如何区分那个对象调用自己的呢？

​		C++通过提供特殊的对象指针，this指针，解决上述问题。==this指针指向被调用的成员函数的所属的对象==。

- this指针是隐含在每一个非静态成员函数的内的一种指针
- this指针不需要定义，直接使用即可

this指针的用途：

- 当形参和成员变量同名时，可用this指针来区分
- 在类的非静态成员函数中返回对象本身，可使用`return *this`

![image-20210825204701875](https://cdn.jsdelivr.net/gh/Sirwenhao/images/C:%5CUsers%5CWH%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images202108252047283.png)

###### 4.3.3 空指针访问成员函数

C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针。如果有用到this指针，需要加以判断保证代码的鲁棒性。

###### 4.3.4 `const`修饰成员函数

常函数：“常”是指函数内部某些数据限定了只读状态

- 成员函数==后==加`const`后我们称这个函数为常函数
- 常函数不可以修改成员属性
- 成员属性声明时加关键字`mutable`后，在常函数中依然可以修改

常对象：

- 声明对象前加`const`称该对象为常对象
- 常对象只能调用常函数

##### 4.4 友元

​		生活中你的家有客厅（public），有你的卧室（private）。客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去。但是呢，你也可以允许你的好闺蜜好基友进去。在程序里，有些私有属性也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术。友元的目的就是==让一个函数或者类访问另外一个类中的私有成员==。

友元的关键字为：`friend`

友元的三种实现：

- ==全局函数==做友元
- ==类==做友元
- ==成员函数==做友元

##### 4.5 运算符重载

运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型

###### 4.5.1 加号运算符重载

​		作用：实现两个自定义数据类型相加的运算。比如对两个默认数据类型整型的相加计算，编译器知道其运算规则，但是对两个自定义数据类型比如说person，其相加操作编译器并不清楚。

![image-20210829143756433](https://cdn.jsdelivr.net/gh/Sirwenhao/images/C:%5CUsers%5CWH%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images202108291437690.png)

总结：

- 对于内置的数据类型的表达式的运算符是不可能改变的
- 不要滥用运算符重载

###### 4.5.2 左移运算符重载

作用：可以输出自定义数据类型

![image-20210829163930597](https://cdn.jsdelivr.net/gh/Sirwenhao/images/C:%5CUsers%5CWH%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images202108291639849.png)

总结：

- 重载左移运算符<<是想实现直接输出对象`cout<<p`即可将对象的所有属性全部输出的操作
- 不能利用成员函数写重载，因为无法实现`cout`在左侧，需使用全局函数
- 使用全局函数写的时候，须注意到`cout`属于输出流`ostream`类型
- 如果属性是私有的，全局函数想要访问属性时必须通过友元这一技术实现
- 重载左移运算符配合友元可以实现输出自定义的数据类型

###### 4.5.3 递增运算符重载

作用：同各国递增运算符，实现自己的整形数据

![image-20210830151130610](https://cdn.jsdelivr.net/gh/Sirwenhao/images/C:%5CUsers%5CWH%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images202108301511974.png)

- 红色框内的输出操作是由于`b++`运算的特点是先执行输出操作，在进行`++`操作
- 蓝色线处是因为`b++`，在执行之后返回值加一，因此在其第二次输出时后进行输出加一之后的值

总结：前置递增返回的是引用，后置递增返回的是值

###### 4.5.4 赋值运算符重载

C++编译器至少给一个类添加4个函数：

- 默认构造函数（无参，函数体为空）
- 默认析构函数（无参，函数体为空）
- 默认拷贝构造函数，对属性进行值拷贝
- 赋值运算符`operator=`，对属性进行值拷贝

如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题。

![image-20210830200856649](https://cdn.jsdelivr.net/gh/Sirwenhao/images/C:%5CUsers%5CWH%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images202108302009691.png)

###### 4.5.5 关系运算符重载

作用：重载关系运算符，可以让两个自定义类型对象进行对比操作

###### 4.5.6 函数调用运算符重载

- 函数调用运算符`()`也可以重载
- 由于重载后使用的方式非常像函数的调用，因此称为==仿函数==
- 仿函数没有固定写法，非常灵活

