## C++学习知识点总结：

### 初识C++

#### 1、C++单行注释与多行注释

![image-20210613104730743](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210613104730743.png)

```c++
多行注释快捷键：control+k+c
```

#### 2、变量

**作用**：给一段指定的内存空间取名，方便对数据进行存取

**语法**：数据类型  变量名 = 初始值；如：

```c++
int a = 10
```

#### 3、常量

**作用：**用于记录程序中不可更改的数据

C++定义常量的两种方式：

- #define宏常量：

  ```c++
  #define 常量名 常量值
  --通常在文件上方定义（反映在程序中就是定义在int main()之前），表示一个常量
  
  ```

  

- `const`修饰的变量：

  ```c++
  const 数据类型 常量名 = 常量值
  --通常在变量定义前加关键字const，修饰改变量为常量，不可修改
  ```

#### 4、关键字

**C++预留的用于作为标识符的单词，在定义变量或者常量的时候不能使用**

### 数据类型

#### 1、标识符的命名规则

即在C++中规定的给（常量或者是标量）进行命名的规则：

- 标识符不能是关键字
- 标识符只能由数字、字母、下划线_组成，斜线啊反斜线之类的都是违法标识符
- ==第一个字符必须是字母或下划线_==，也就是说不能是数字呗，好像和Python一毛一样
- 在标识符中，字母大小写是有区分的
- 建议：在给变量起名时，最好能做到见名知意

#### 2、数据类型：

C++规定在创建一个变量或者常量时，必须制定出其相应的数据类型，这样便于计算机==给变量或者常量分配相应的内存==，在计算机中对数据进行空间分配时，既不能分配过大的内存空间也不能分配过小的内存空间，太大资源浪费，太小存不下。因此，数据类型定义的核心任务就是给变量分配==合适的内存空间==。

##### 2.1、整型：即==整数类型==的数据

在C++中共有四种可以表示整型数据的类型：（长长整型在输入时输的是long long，==两个long中间是有一个空格的==）

| 数据类型            | 占用空间                                        | 取值范围                 |
| ------------------- | ----------------------------------------------- | ------------------------ |
| short(短整型)       | 2字节                                           | $$-2^{15}$$~$$2^{15}-1$$ |
| int(整型)           | 4字节                                           | $$-2^{31}$$~$$2^{31}-1$$ |
| long(长整型)        | Windows为4字节，Linux为4字节(32位)，8字节(64位) | $$-2^{31}$$~$$2^{31}-1$$ |
| long long(长长整型) | 8字节                                           | $$-2^{63}$$~$$2^{63}-1$$ |

##### 2.2、sizeof关键字：

作用：统计数据类型所占内存的大小

- 语法为：

  ```c++
  sizeof(数据类型 / 变量)  数据类型或变量的意思
  ```

##### 2.3、实型（浮点型）

作用是：用于表示小数

- 浮点型变量分两种：两者的区别在于表示的==有效数字的范围不同==。如3.14包含三位有效数字3、1、4.

  1、单精度浮点型float

  2、双精度浮点型double

| 数据类型 | 占用空间 | 有效数字范围    |
| -------- | -------- | --------------- |
| float    | 4字节    | 7位有效数字     |
| double   | 8字节    | 15~16位有效数字 |

##### 2.4、字符型

作用 ：字符型变量用于显示单个字符

语法为：

```c++
char ch = 'a';
| 注意1：字符变量使用单引号''括起来
| 注意2：单引号内只能有一个字符
```

- C和C++中字符型变量只占用一个字节
- 字符型变量在存储时并不是把自身放到内存中存储，而是将对应的ASCII码放入到存储单元

##### 2.5、字符串型

作用：用于表示一串字符

语法为：

```c++
1、C语言风格的字符串：char 变量名[] = "字符串值"
2、C++风格字符串：string 变量名 = "字符串值"
```

注意：C++风格的字符串在使用时必须包含==头文件==

```c++
#include <string>
```

##### 2.6、布尔类型

作用：布尔数据类型代表的是真或者假的值

**bool**类型有两种值：

- true ----- 真（本质是1）
- false ----- 假（本质是0）

布尔类型占==一个字节==大小

##### 2.7、数据输入

作用：用于从键盘获取输入信息

关键字：**cin**

语法：

```c++
cin >> 变量
```

### 运算符

##### 1、运算符作用：用于执行代码的运算

本部分主要讲解一下运算符：

| 运算符类型 | 作用                                   |
| ---------- | -------------------------------------- |
| 算术运算符 | 用于处理四则运算                       |
| 赋值运算符 | 用于将表达式的值赋给变量               |
| 比较运算符 | 用于表达式的比较，并返回一个真值或假值 |
| 逻辑运算符 | 用于根据表达式的值返回真值或假值       |

##### 2、算术运算符

作用：用于处理四则运算

算术运算符包含以下符号：

| 运算符 | 术语         | 示例            | 结果          |
| ------ | ------------ | --------------- | ------------- |
| +      | 正号         | +3              | 3             |
| -      | 负号         | -3              | -3            |
| +      | 加           | 10 + 5          | 15            |
| -      | 减           | 10 - 5          | 5             |
| *      | 乘           | 10 * 5          | 50            |
| /      | 除           | 10 / 5          | 2             |
| %      | 取模（取余） | 10 % 3          | 1             |
| ++     | 前置递增     | a = 2; b = ++a; | a = 3; b = 3  |
| ++     | 后置递增     | a = 2; b = a++  | a = 3; b = 2; |
| --     | 前置递减     | a = 2; b = --a; | a = 1; b = 1; |
| --     | 后置递减     | a = 2; b = a--; | a = 1; b = 2; |

##### 3、赋值运算符

作用：用于将表达式的值赋给变量

赋值运算符包含以下符号：

| 运算符 | 术语   | 示例          | 结果         |
| ------ | ------ | ------------- | ------------ |
| =      | 赋值   | a = 2;b = 3;  | a = 2;b = 3; |
| +=     | 加等于 | a = 0;a += 2; | a = 2;       |
| -=     | 减等于 | a = 5;a -= 3; | a = 2;       |
| *=     | 乘等于 | a = 2;a *= 2; | a = 4;       |
| /=     | 除等于 | a =4;a /= 2;  | a = 2;       |
| %=     | 模等于 | a =3;a % 2;   | a = 1;       |

##### 4、比较运算符

作用：用于表达式的比较，并返回一个真值或者假值

比较运算符有以下符号：

| 运算符 | 术语     | 示例   | 结果 |
| ------ | -------- | ------ | ---- |
| ==     | 相等于   | 4 == 3 | 0    |
| !=     | 不等于   | 4 != 3 | 1    |
| <      | 大于     | 4 < 3  | 0    |
| >      | 小于     | 4 > 3  | 1    |
| <=     | 小于等于 | 4 <= 3 | 0    |
| >=     | 大于等于 | 4 >= 1 | 1    |

##### 5、逻辑运算符

根据表达式的值返回真值或假值

逻辑运算符有以下符号：

| 运算符 | 术语   | 示例         | 结果                                                     |
| ------ | ------ | ------------ | -------------------------------------------------------- |
| ！     | 非     | !a           | 如果a为假，则!a为真；如果a为真，则!a为假。               |
| &&     | 与     | a && b       | 如果a和b都为真，则结果为真，否则为假。                   |
| \|\|   | ==或== | ==a \|\| b== | 如果a和b有一个为真，则结果为真，二者都为假时，结果为假。 |

##### 程序流程结构

C/C++支持三种最基本的程序运行结构：==顺序结构、选择结构、循环结构==

- 顺序结构：程序顺序执行，不跳转
- 选择结构：根据条件是否满足，有选择地执行相应功能
- 循环结构：依据条件是否满足，循环多次执行某段代码

##### 4.1选择结构

###### 4.1.1 if语句

作用：执行满足条件的语句 

**if**语句的三种形式

- 单行格式**if**语句
- 多行格式**if**语句
- 多条件**if**语句

1.单行格式的**if**语句：

```c++
if(条件){满足条件时，要执行的语句}
```

2.多行格式**if**语句

```c++
if（条件）{条件满足执行的语句}else{条件不满足执行的语句}；
```

3.多条件**if**语句

```c++
if(条件1)（条件1满足时执行的语句）else if(条件2)（条件2满足时执行的语句）...else(都不满足时执行的语句)
```

![image-20210623103241855](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210623103241855.png)

嵌套if语句：在if语句中可以嵌套使用if语句，做更细致的条件判断

案例需求：

- 提示一用户输入高考分数，根据分数做如下判断

- 分数如果大于600分视为考上一本，大于500分视为考上二本，大于400分视为考上三本，其余视为未考上本科

- 在一本分数中，大于700分，考入清华，大于650分，考入北大，大于600分，考入人大


##### 三目运算符

作用：通过三目运算符实现简单的判断

语法：

```c++
表达式1？表达式2：表达式3
```

==解释：如果表达式1的值为真，执行表达式2，并返回表达式2的结果；如果表达式1的值为假，执行表达式3，并返回表达式3的结果。==

##### switch语句

作用：执行多条件分支语句

语法：

```c++
switch（表达式）
{

	case结果1：执行语句；break；
	
	case结果2；执行语句；break;
	
	...
	
	default：执行语句；break；

}
```

根据表达式的结果选择执行那个分支，结果为1就选case结果1，结果为2就选case结果2，依次类推，如果都没有就选default。

| 注意1：`switch`语句中==表达式类型只能是整型或者字符型==

| 注意2：`case`里面如果没有==`break`==，那么程序会一直向下执行

| 总结：与if语句相比，对于多条件判断时，switch结构清晰，执行效率高，缺点是switch语句不能判断区间

##### 4.2循环结构

###### 4.2.1 `while`循环语句

作用：满足循环条件的情况下，执行循环体

语法：

```C++
while（循环条件）{循环语句}
```

解释：只要循环的条件结果为真，就执行循环语句

![image-20210626103031853](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210626103031853.png)

注意：`while`后面的括号中填入的是满足的条件，另外一定要避免死循环的出现。

`while`循环练习题

![image-20210626105008475](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210626105008475.png)

###### 4.4.2 `do...while`循环语句

作用：满足循环条件，执行循环条件

语法：

```c++
do{循环语句} while （循环条件）；
```

注意：与`while`的区别在于`do...while`会先执行一次循环语句，在判断循环条件

![image-20210627073257457](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210627073257457.png)

练习题水仙花数

![image-20210627080735434](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210627080735434.png)

在C++中整数和整数之间除法，返回值也是==整数==无论是否整除

###### 4.2.3 `for`循环

作用：满足循环条件，执行循环语句

语法：

```c++
fo（起始表达式；条件表达式；结尾表达式）{ 循环语句； }
```

`for`循环执行步骤示意图：

![image-20210628150900978](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210628150900978.png)

| 注意：`for`循环中的表达式要用分号进行分割

| 总结：`while`，`do…while`，`for`都是开发中常用的循环语句，`for`循环结构比较清晰

练习案例：敲桌子。从1开始数到数字100，如果数字个位含有7，或者十位数字含有7，或者是7的倍数，我们打印敲桌子，其余数字直接打印输出。

###### 4.2.4 嵌套循环

作用：在循环体中在嵌套一层循环，解决一些实际问题

练习案例：打印星图

练习案例：九九乘法表，要求：利用嵌套循环实现

- 首先：共有九行九列数据，且乘法表中乘号左侧数字均相同为列数，乘号右侧数字逐渐增加为行数。列数*行数为结果。
- 其次：通过列数小于等于当前行数这一特点，可以控制表中空白的那一半

![image-20210629151045540](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210629151045540.png)

##### 4.3 跳转语句

###### 4.3.1 `break`语句

作用：用于跳出==循环结构==或者==选择结构==

`break`使用的时机：

- 出现在`switch`条件语句中，作用是终止`case`并跳出`switch`
- 出现在循环语句中，作用是跳出当前的循环语句
- 出现在嵌套循环中，跳出最近的内层循环

###### 4.3.2 `continue`语句

作用：再循环语句中，==跳过本次循环中余下未执行的语句==，继续==执行下一次循环==

案例：输出奇数偶数

###### 4.3.3 `goto`语句

作用：可以跳过某些语句进而执行其他语句

语法：

```c++
goto 标记;
```

```c++
int main()
{
	//goto语句

cout << "1、XXXX" << endl;

cout << "2、XXXX" << endl;

goto FLAG;  //goto 后面定义的标记之后是分号

cout << "3、XXXX" << endl;

cout << "4、XXXX" << endl;

FLAG:  //标记后面是冒号

cout << "5、XXXX" << endl;

system("pause");

return 0;

}
```

#### 5、数组

##### 5.1 概述

数组：即一个数据集和，其中存放了许多相同类型的元素

特点1：数组中的每个数据元素都是相同的数据类型

特点2：数组是由==连续的内存位置==组成的，可以通过下标来访问数组中的元素，从0开始的

##### 5.2 一维数组

###### 5.2.1 一维数组的定义方式

一维数组定义的三种方式：

```c++
1、数据类型  数组名[ 数组长度 ]；
```

```c++
2、数据类型  数组名[ 数组长度 ] = {值1，值2，…}；
```

```c++
3、数据类型  数组名[ ] = {值1，值2，…}；
```

###### 5.2.2 一维数组数组名

一维数组数组名的用途：

1. 可以统计整个数组在内存中的长度，使用**`sizeof(arr)`**命令
2. 可以获取数组在内存中的首地址，使用**`cout << arr[0] << endl`**
3. **`sizeof(arr[0])`**可以获取到数组**arr**中第一个元素所占的内存空间大小，元素个数可以通过**`sizeof(arr)/size(arr[0])`**

练习案例1：五支小猪称体重

案例分析：在一个数组中记录了五只小猪的体重，如：**`int arr[5] = {300,350,200,400,250}`**

找出并打印出最重的小猪的体重



练习案例2：数组元素逆置

案例描述：请声明一个5个元素的数组，并且将元素逆置。

（如原数组元素为：1，3，2，5，4；逆置后输出的结果为：4，5，2，3，1）

思考过程见下图

![image-20210703161211783](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210703161211783.png)

###### 5.2.3 冒泡排序

作用：最常用的排序算法，对数组内元素进行排序

1、比较相邻的元素。如果第一个比第二个大，就交换位置（这种是从小到大排列）。

2、对每一对相邻元素做同样的工作，执行完毕后，找到第一个最大值。

3、重复执行上述步骤，每次比较次数减一，直至结束。

解题思路：

![image-20210703212650230](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210703212650230.png)

##### 5.3 二维数组

二维数组相较于一维数组，即在其原有的维度上拓展了一个新的维度。

###### 5.3.1 二维数组定义的四种方式：

```c++
1、数据类型 数组名[ 行数 ][ 列数 ];
```

```c++
2、数据类型 数组名[ 行数 ][ 列数 ] = { { 数据1,数据2 },{ 数据3,数据4 } };
```

```c++
3、数据类型 数组名[ 行数 ][ 列数 ] = { 数据1,数据2,数据3,数据4 };
```

```c++
4、数据类型 数组名[ ][ 列数 ] = { 数据1，数据2，数据3，数据4 };
```

建议：以上四种定义方式，第二种较为直观，代码可读性较强

###### 5.3.2 二维数组数组名

二维数组名称的两种用途：

- 查看二维数组所占==内存空间==
- 获取二维数组==首地址==

###### 5.3.3 二维数组应用案例

考试成绩统计：

案例描述：有三名同学（张三，李四，王五），在一次考试中的成绩分别如下表，请分别输出三名同学的总成绩

|      | 语文 | 数学 | 英语 |
| :--: | :--: | :--: | :--: |
| 张三 | 100  | 100  | 100  |
| 李四 |  90  |  50  | 100  |
| 王五 |  60  |  70  |  80  |

#### 6、 函数的定义

##### 6.1 概述

作用：将一段代码封装起来，减少重复代码。将一个大的代码分为若干个程序块，每个模块实现特定的功能。

##### 6.2 函数的定义

函数的定义一般主要有5个步骤：

1、返回值类型

2、函数名

3、参数列表

4、函数体语句

5、**`return`**表达式

**语法：**

```c++
返回值类型 函数名 （参数列表）
{
	函数体语句;
	
	return表达式;
}
```

##### 6.3 函数的调用

功能：使用定义好的函数结构体

语法：

```c++
函数名（参数）
```

注意：函数定义时传入的参数称为形参，函数调用时传入的参数称为实参

#####  6.4 值传递

- 所谓值传递，即在==函数调用时==实参将数值传入给形参

- ==值传递==时，若==形参==发生改变，并不会影响实参

  值传递的解释：

![image-20210707093420674](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210707093420674.png)

在此段程序执行期间，`a`和`b`的值均未发生改变，对应的变量都有为其开辟的内存地址以及相应的值。

##### 6.5 函数的常见样式

函数常见样式有四种：

- 有参无返
- 无参无返
- 无参有返
- 有参有返

##### 6.6 函数声明

作用：告诉编译器函数名称以及如何调用函数，函数的实际主体可以单独定义。

注意：函数的声明可以有多次，函数的定义只能有一次

##### 6.7 函数的分文件编写

作用：让代码结构更加清晰，因为目前我们所写的代码都在一个文件夹中，如果代码过长就需要不停的返回去找，过于浪费时间。

函数份文件编写一般有四个步骤：

- 创建后缀名为`**.h**`的头文件
- 创建后缀名为**`.cpp`**的源文件
- 在==头文件==中写函数的==声明==
- 在==源文件==中写函数的==定义==

#### 7、指针

##### 7.1 指针的基本概念

**指针的作用**：可以通过指针间接**访问内存**

- 内存编号是从0开始记录的，一般用十六进制数字表示
- 可以==利用指针变量保存地址==，指针就是一个==变量==，指针中存储的就是一个==地址==

##### 7.2 指针变量的定义和使用

指针变量定义语法：

```
数据类型 * 指针变量名;
```

##### 7.3 指针所占内存空间

指针也是一种数据类型，那么指针这种数据类型占多少内存空间呢？在32位操作系统中，指针占用==四个字节==空间；在64位操作系统中，指针占用==八个字节==空间。

##### 7.4 空指针和野指针

**空指针**：指针变量指向内存中==编号为0的空间==

**用途**：==初始化==指针变量（当一开始指针不知指向何处时，可将其指向此处）

**注意**：空指针指向的内存是==不可以访问的==（0-255这块内存是系统占用的不能被指针所访问）

**野指针**：指向非法的内存空间

##### 7.5 *`const`*修饰指针

**`const`**修饰指针有三种情况：

1. **`const`**修饰指针  --- 常量指针
2. **`const`**修饰常量  --- 指针常量
3. **`const`**即修饰指针，又修饰常量

第一种：**`const`**修饰指针中，==指针的指向可以修改（即指针指向的位置是可以改变的，但是指针指向的原始位置中的值是不能修改的）==，但==指针所存内容不可修改==。语法为：

```c++
const int * p = &a
```

![image-20210711085844710](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210711085844710.png)

如上图：a，b均为一个值为10的变量，地址不同。**`int * p = &a`**表示**`p`**这个指针指向的就是**`a`**的地址**`0x0011`**，`* p`即表示这个地址（**`0x0011`**）中存储的内容：10。用**`const`**修饰常量指针（即指针是一个常量，比如此例中地址都是确定的），这种情况下==指针的指向（即指针的值）可以修改==，但==指针指向的位置中内容不能修改==。

第二种：**`const`**修饰常量中，==指针的指向（即指针指向的那个地址不能修改）不可修改==，==指针指向的内容可以修改==。**`const`**修饰常量语法为：

```c++
int * const p = &a
```

![image-20210711091247809](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210711091247809.png)

如上图：a，b均为一个值为10的变量，地址不同。**`int * p = &a`**表示**`p`**这个指针指向的就是**`a`**的地址**`0x0011`**，`* p`即表示这个地址（**`0x0011`**）中存储的内容10.

**`p`**本是变量，**`const`**修饰之后，**`const p`**视为常量，因此得名指针常量，这种情况下==指针的指向（即原指针地址）不可修改==，==指针指向的内容（即原指针中所存的内容）可以修改==。

第三种：**`const`**即修饰指针，又修饰常量，此种情况中==指针的指向和指针指向的值都不可以修改==

![image-20210711092249940](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210711092249940.png)

如上图，即修饰指针又修饰变量的语法为：

```c++
const int * const p = &a
```

**Tips：**记忆方法

1、记忆常量指针还是指针常量，只需要看**`const`**和*****以及**`p`**的相对位置。**`const`**译成中文是常量的意思，若**`const`**后面紧跟的是指针*****就表示是常量指针，若*****在前，指针**`const`**在后则称为指针常量。即观察*****的位置和**const**的位置。

2、记忆那个可以修改

如：**`const`**后面是指针**`p`**，已被**`const`**限定所以不能修改

```c++
int * const p = &a
```

如：`const`后面紧跟的是*****，则`***p**`已被限定不能修改

```c++
const int * p = &a
```

##### 7.6 指针和数组

作用：利用指针访问数组中元素，目的是利用指针访问数组中的每一个元素

##### 7.7 指针和函数

作用：利用指针做函数的参数，可以修改实参的值(参考上述值传递部分，简单推理一下，理解一下两者的区别)

![image-20210712095335843](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210712095335843.png)

注意：

- 值传递不会改变实参
- 地址传递会改变实参

##### 7.8 指针、数组、函数

案例描述：封装一个函数，使用冒泡排序，实现对整型数组的升序排序

例如数组：

```c++
int arr[10]  =  {4,3,6,9,1,2,10,8,7,5}
```

此程序的一些核心点：

- 如何把一个数组传递到一个函数中
- 第二点冒泡排序熟练使用
- 最好传入数组的长度

#### 8、结构体

##### 8.1 结构体的基本概念

结构体属于用户==自定义的数据类型==，允许用户存储不同的数据类型（就是说学了结构体之后，除了C++自定义的数据类型，自己也可以==创造新的数据类型==）

##### 8.2 结构体定义和使用

语法：

```c++
struct 结构体名 {结构体成员列表}；
```

通过结构体创建变量的方式有三种：

- `struct`  结构体名 变量名
- `struct`  结构体名 变量名 = {成员1值，成员2值...}
- 定义结构体时顺便创建变量

##### 8.3 结构体数组

作用：将自定义的结构体放入到数组中方便维护

语法：

```c++
struct 结构体名 数组名[元素个数] = { {}，{}，...，{} }
```

##### 8.4 结构体指针

作用：通过指针访问结构体中的成员

- 利用操作符 `->` 可以通过结构体指针访问结构体属性

##### 8.5 结构体嵌套结构体

作用：结构体中的成员可以是另一个结构体

比如：每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体。即在一个结构体中，将另一个结构体当作此结构体中的一个成员。

![image-20210714155219624](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210714155219624.png)

##### 8.6 结构体做函数参数

作用：将结构体作为参数向函数中传递

传递方式：两种

- 值传递
- 地址传递

##### 8.7 结构体中的`const`的使用场景

**作用：**用**`const`**来防止误操作，见例55

##### 8.8 结构体的案例

8.8.1 案例1

​		**案例描述**：学校正在做毕设项目，每个老师带领五个学生，总共有三名老师，需求如下：设计老师和学生的结构体，其中在老师的结构体中，有老师姓名和存放五个学生的数组作为成员，学生的成员有姓名、考试分数，创建数组存放3明老师，通过函数给每个老师即所带的学生赋值，最终打印出老师的数据以及老师所带的学生数据。

8.8.2 案例2

​		案例描述：设计一个英雄的结构体，包括成员的姓名年龄，性别；创建结构体数组，数组中存放五名英雄，通过冒泡排序法，将英雄按照年龄升序进行排序，最终打印排序后的结果。

### C++核心编程

本阶段主要针对C++==面向对象==编程技术做详细讲解，探讨C++中的核心与精髓。

#### 1 内存分区模型

![image-20210906085958707](https://cdn.jsdelivr.net/gh/Sirwenhao/images/C:%5CUsers%5CWH%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images202109060900980.png)

C++程序在执行时，将内存大方向划分为**四个区域**：

- 代码区：存放函数体的二进制代码，由操作系统进行管理
- 全局区：存放==全局变量==和==静态变量==以及==常量==
- 栈区：由编译器自动分配释放，存放==函数的参数值==，==局部变量==等
- 堆区：==由程序员分配和释放==，若程序员不释放，程序结束时由操作系统回收

内存四区的意思：

​		不同区域存放的数据，赋予不同的生命周期，给我们的更大的变成灵活性。

##### 1.1 程序运行前

​		在程序编译后，生成了可执行程序，未执行该程序前分为两个区域

代码区：

- 存放CPU执行的机器指令
- 代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可
- 代码区是只读的，使其只读的原因是防止程序以外的修改了它的指令

全局区：

- 全局变量和静态变量存放在此
- 全局区还包含了常量区，字符串常量和其他常量(这个其他常量专指用`const`修饰的变量)也存放在此
- 该区域的数据子程序结束后由操作系统释放

![image-20210807204539015](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210807204539015.png)

总结：

- C++中在程序运行前分为全局区和代码区
- 代码区特点是共享和只读
- 全局区中存放的全局变量、静态变量、常量
- 常量区中存放`const`修饰的全局常量和字符串常量

##### 1.2 程序运行后

栈区：

- 由编译器自动分配释放，存放函数的参数值，局部变量等

- 注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放

堆区：

- 由程序员分配释放，若程序员不释放，程序结束时由操作系统回收
- 在C++中主要利用==`new`==在堆区开辟内存

注意：

- 堆区数据由程序员管理开辟和释放
- 堆区数据利用==new关键字==进行开辟内存

##### 1.3 new操作符

- C++利用new操作符在堆区开辟数据
- 堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符**delete**

语法：

```c++
new 数据类型
```

利用new创建的数据，会返回该数据对应的类型的指针

#### 2 引用

##### 2.1 引用的基本使用

作用：给变量起==别名==

语法：

```c++
数据类型 &别名 = 原名
```

注意：

- ==数据类型==与原变量的数据类型必须==相同==

![image-20210810210542400](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210810210542400.png)

引用之后相当于，两个名字指向的都是同一个位置，若更改b则a也会随之被修改。

##### 2.2 引用注意事项

- 引用必须==初始化==
- 引用在初始化后，不可以改变

![](https://cdn.jsdelivr.net/gh/Sirwenhao/images/C:%5CUsers%5CWH%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images202108181006253.png)

##### 2.3 引用做函数参数（引用起的别名可以和原来的名字相同）

**作用**：函数传参时，可以利用引用的技术让==形参修饰实参==

**优点**：可以简化指针修改实参

总结：形参修饰实参的两种方法，实例见62引用做函数参数示例

- 地址传递
- 引用传递

##### 2.4 引用做函数返回值

作用：引用是可以作为函数的返回值存在的

注意：不要返回==局部变量引用==

用法：函数调用作为左值

##### 2.5 引用的本质

**本质：**引用的本质在C++内部实现是一个==指针常量==。引用一旦初始化之后，就不可以发生改变。

![](https://cdn.jsdelivr.net/gh/Sirwenhao/images/C:%5CUsers%5CWH%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images202108181005563.png)

```c++
int * const ref = &a
ref指向地址0x0011，由于ref是指针常量，所以ref的指向是固定的只能指定当前的地址编号0x0011不能修改。而指针指向的值是可以修改的，比如此地址中存放的数据10是可以进行修改的。
```

结论：C++推荐用引用结束，因为语法方便，==引用本质是指针常量==，但所有的指针操作编译器都帮我们做了

##### 2.6 常量引用

作用：常量引用主要用来修饰形参，防止误操作

在函数形参列表中，可以加==**`const`**修饰形参==，防止形参改变实参。因此，在定义函数时，需要考虑一下调用函数之后，函数形参或者实参是否会发生改变，并且是否会影响结果。

#### 3 函数提高

##### 3.1 函数默认参数

在C++中，函数的形参列表中的形参是可以有默认值的。

语法：

```C++
返回值类型 函数名 （参数 = 默认值）{}
```

##### 3.2 函数占位参数

C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置。在现阶段，函数的占位存在意义不大，但是后面的课程中会用到该技术。

语法：

```c++
返回值类型 函数名 （数据类型）{}
```

##### 3.3 函数重载

###### 3.3.1 函数重载概述

作用：**函数名相同，提高复用性**

函数重载满足条件：

- 同一个作用域下
- 函数名称相同
- 函数参数**类型不同**或者**个数不同**或者**顺序不同**

###### 3.3.2 函数重载注意事项

- 引用作为重载条件
- 函数重载碰到函数默认参数

------

正式进入C++编程核心中的核心

#### 4 类和对象

C++面向对象的三大特性为：==封装==、==继承==、==多态==

C++认为万事万物皆为对象，对象上有其属性和行为。

例如：

人可以作为对象，属性有姓名、年龄、身高、体重，行为有：走、跑、跳、吃饭、唱歌......

具有相同性质的==对象==，可以抽象为==类==，人属于人类

##### 4.1 封装

###### 4.1.1 封装的意义

封装是C++面向对象三大特性值一，封装的意义：

- 将属性和行为作为一个整体，表现生活中的事物
- 将属性和行为加以权限控制

封装意义一：

在设计类的时候，属性和行为写在一起，表现事物

语法：

```c++
class 类名{  访问权限：属性 / 行为  }；
```

封装意义二：

类在设计时，可以把属性和行为放在不同的权限下，加以控制

访问权限有三种：

- `public`          公共权限
- `protected`     保护权限
- `private`         私有权限

###### 4.1.2 `struct`和`class`的区别

在C++中`struct`和`class`的==唯一区别==就在于：==默认的访问权限不同==。区别：

- `struct`  默认访问权限为==公共==
- `class`  默认访问权限位==私有==

###### 4.1.3 成员属性设置为私有

优点：

- 将所有==成员属性==设置为==私有==，可以自己控制读写权限
- 对于写权限，我们可以检测数据的有效性

**练习案例1：设计立方体类**

​		设计立方体类（***`Cube`***）

​		求出立方体的面积和体积

​		分别用全局函数和成员函数判断两个立方体是否相等

**练习案例2：点和圆的关系**

​		设计一个圆形类（***`Circle`***）和一个点类（***`Point`***），计算点和圆的关系。此案例中还讲解了如何将一个类分解出多个，分文件编写。

​		此案例两个核心点：

- 在一个类中让另外一个类作为此类的成员
- 如何把一个类拆成不同的文件。如此例中将点类、圆类分别写入两个头文件和***`cpp`***可执行文件中，然后注意学习下在头文件中应该怎么写，在***`cpp`***文件中有该怎么写。在头文件中留下所有成员函数的声明和成员属性的声明，在***`cpp`***文件中要讲清楚是成员函数，并使用如：`Circle::，Point::`等字符加以说明。

##### 4.2 对象的初始化和清理

- 类似于生活中我们所使用电子产品的**出厂设置**，在某一天我们不用的时候也会删除一些自己的信息数据保证安全
- C++中的面向对象来源于生活，每个对象也都会有初始设置以及对象销毁前的是清理数据的设置

###### 4.2.1 构造函数和析构函数

对象的==初始化==和==清理==也是两个非常重要的安全问题

- 一个对象或者变量没有初始状态，对其使用后果是未知
- 同样使用完一个对象或者变量，没有及时清理，也会造成一定的安全问题

因此，C++中引入==构造函数==和==析构函数==解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。对象的初始化和清理工作是编译器强制要我们做的事情，因此如果==我们不提供构造和析构，编译器会提供。编译器提供的构造函数和析构函数是空实现。==空实现是指编译器提供的函数体是空的。

- 构造函数：主要作用在于创建对象时==为对象的成员属性赋值，即初始化类对象的成员数据==，构造函数由编译器自动调用，无需手动调用
- 析构函数：主要作用在于对象==销毁前==系统自动调用，执行一些清理工作

构造函数的语法：`类名(){}`

1. 构造函数，没有返回值也不写`void`
2. 函数名称与类名==相同==
3. 构造函数可以有==参数==，因此==可以发生重载==
4. 程序在调用对象时候会自动调用构造，无需手动调用，而且只会调用一次

析构函数的语法：`~类名(){}`

1. 析构函数，没有返回值也不写`void`
2. 函数名称与类名==相同==，在名称前加上==符号~==
3. 析构函数==不可以有参数，因此不可以发生重载==
4. 程序在对象销毁前会自动调用析构，无需手动调用，而且只会调用一次

###### 4.2.2 构造函数的分类及调用

两种分类方式：

- 按参数分为：有参构造和无参构造
- 按类型分为：普通构造和拷贝构造

三种调用方式：

- 括号法
- 显示法
- 隐式转换法

######  4.2.3 拷贝构造函数调用时机

C++中拷贝构造函数调用时机通常有三种情况

- 使用一个已经创建完毕的对象来初始化一个新的对象
- 值传递的方式给函数参数传值
- 以值方式返回局部对象

###### 4.2.4 构造函数调用规则

默认情况下，C++编译器至少给一个类添加3个函数

- 默认构造函数（无参，函数体为空）
- 默认析构函数（无参，函数体为空）
- 默认拷贝构造函数，对属性值进行拷贝

构造函数调用规则如下：

- 如果用户定义有参构造函数，C++不再提供默认无参构造，但是会提供默认拷贝构造
- 如果用户定义拷贝构造函数，C++不会再提供其他构造函数

根据本小节示例，可以总结如下（对应以上调用规则）：

- 如果提供了有参构造函数，则编译器不再提供默认构造函数，但会提供拷贝构造函数
- 如果提供了拷贝构造函数，则编译器不再提供默认构造函数，也不会提供有参构造函数

###### 4.2.5 深拷贝与浅拷贝

​		深浅拷贝是面试经典问题，也是一个常见的坑。浅拷贝：简单的复制拷贝操作。深拷贝，在==堆区==重新申请空间，进行拷贝操作。

![image-20210822195301559](https://cdn.jsdelivr.net/gh/Sirwenhao/images/C:%5CUsers%5CWH%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images202108221953703.png)

- 创建了两个对象`p1`和`p2`，每个对象都包含两种属性，年龄和身高
- 利用编译器提供的拷贝构造函数，做浅拷贝实际上就是逐字节的将对象`p1`的属性拷贝到对象`p2`中
- 当执行析构函数的时候，两个对象都会执行析构。按照栈==先进后出==的规则，后入栈的对象`p2`会被先析构。
- 后入栈的对象`p2`先被析构，堆区上的内存`0x0011`会被释放，等到对象`p1`析构时，此内存又会被析构函数重复操作，重复析构。这就是浅拷贝所带来的问题（==堆区的内存重复释放==），堆区的内存重复释放。
- 堆区内存重复释放的问题，可以由深拷贝来解决。

![image-20210822193758108](https://cdn.jsdelivr.net/gh/Sirwenhao/images/C:%5CUsers%5CWH%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images202108221938180.png)

- 重新在堆区找一块内存地址，这样析构时是对两个地址分别执行，就不会重复释放同一块内存地址了。

###### 4.2.6 初始化列表

**作用：**C++提供了初始化列表语法，用来初始化属性

语法：`构造函数()：属性1(值1)，属性2(值2)...{}`

###### 4.2.7 类对象作为类成员

C++类中的成员可以是另一个类的对象，我们称改成员为对象成员

例如：

```c++
class A {}
class B
{
	A a;
}
```

B类中有对象A作为成员，A为对象成员。那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？答案是先A，当其它类的对象作为我本类的成员时，那么我创建本类的对象时，他会先构造其他的类的对象

###### 4.2.8 静态成员

静态成员就是在成员变量和成员函数前加关键字==static==，称为静态成员。静态成员可以分为：

- 静态成员变量
  - 所有对象共享同一份数据
  - 在编译阶段分配内存
  - ==类内声明，类外初始化==
- 静态成员函数
  - 所有对象共享同一函数
  - 静态成员函数==只能==访问静态成员变量

![image-20210824213219726](https://cdn.jsdelivr.net/gh/Sirwenhao/images/C:%5CUsers%5CWH%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images202108242132942.png)

##### 4.3 C++对象模型和this指针

###### 4.3.1 成员变量和成员函数分开存储

在C++中，类内的成员变量和成员函数分开存储。==只有非静态成员变量才属于类的对象上==。

###### 4.3.2 `this`指针概念

​		通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的，每一个非静态成员函数只会诞生一份函数实例，而就是说多个同类型的对象会共用一块代码，那么问题是：这一块代码是如何区分那个对象调用自己的呢？

​		C++通过提供特殊的对象指针，this指针，解决上述问题。==this指针指向被调用的成员函数的所属的对象==。

- `this`指针是隐含在每一个非静态成员函数的内的一种指针
- `this`指针不需要定义，直接使用即可

`this`指针的用途：

- 当形参和成员变量同名时，可用this指针来区分
- 在类的非静态成员函数中返回对象本身，可使用`return *this`

![image-20210825204701875](https://cdn.jsdelivr.net/gh/Sirwenhao/images/C:%5CUsers%5CWH%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images202108252047283.png)

###### 4.3.3 空指针访问成员函数

C++中空指针也是可以调用成员函数的，但是也要注意有没有用到`this`指针。如果有用到this指针，需要加以判断保证代码的鲁棒性。

###### 4.3.4 `const`修饰成员函数

常函数：“常”是指函数内部某些数据限定了只读状态

- 成员函数==后==加`const`后我们称这个函数为常函数
- 常函数不可以修改成员属性
- 成员属性声明时加关键字`mutable`后，在常函数中依然可以修改

常对象：

- 声明对象前加`const`称该对象为常对象
- 常对象只能调用常函数

##### 4.4 友元

​		生活中你的家有客厅（public），有你的卧室（private）。客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去。但是呢，你也可以允许你的好闺蜜好基友进去。在程序里，有些私有属性也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术。友元的目的就是==让一个函数或者类访问另外一个类中的私有成员==。

友元的关键字为：`friend`

友元的三种实现：

- ==全局函数==做友元
- ==类==做友元
- ==成员函数==做友元

##### 4.5 运算符重载

运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型

###### 4.5.1 加号运算符重载

​		作用：实现两个自定义数据类型相加的运算。比如对两个默认数据类型整型的相加计算，编译器知道其运算规则，但是对两个自定义数据类型比如说person，其相加操作编译器并不清楚。

![image-20210829143756433](https://cdn.jsdelivr.net/gh/Sirwenhao/images/C:%5CUsers%5CWH%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images202108291437690.png)

总结：

- 对于内置的数据类型的表达式的运算符是不可能改变的
- 不要滥用运算符重载

###### 4.5.2 左移运算符重载

作用：可以输出自定义数据类型

![image-20210829163930597](https://cdn.jsdelivr.net/gh/Sirwenhao/images/C:%5CUsers%5CWH%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images202108291639849.png)

总结：

- 重载左移运算符`<<`是想实现直接输出对象`cout<<p`即可将对象的所有属性全部输出的操作
- ==不能利用成员函数写重载==，因为无法实现`cout`在左侧，需使用全局函数
- 使用全局函数写的时候，须注意到`cout`属于==输出流`ostream`类型==
- 如果属性是私有的，全局函数想要访问属性时必须通过友元这一技术实现
- 重载左移运算符配合友元可以实现输出自定义的数据类型

###### 4.5.3 递增运算符重载

作用：通过重载递增运算符，实现自己的整型数据

![image-20210830151130610](https://cdn.jsdelivr.net/gh/Sirwenhao/images/C:%5CUsers%5CWH%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images202108301511974.png)

- 红色框内的输出操作是由于`b++`运算的特点是先执行输出操作，再进行`++`操作
- 蓝色线处是因为`b++`，在执行之后返回值加一，因此在其第二次输出时后进行输出加一之后的值

总结：前置递增返回的是引用，后置递增返回的是值

###### 4.5.4 赋值运算符重载

C++编译器至少给一个类添加4个函数：

- 默认构造函数（无参，函数体为空）
- 默认析构函数（无参，函数体为空）
- 默认拷贝构造函数，对属性进行值拷贝
- 赋值运算符`operator=`，对属性进行值拷贝

如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题。

![image-20210830200856649](https://cdn.jsdelivr.net/gh/Sirwenhao/images/C:%5CUsers%5CWH%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images202108302009691.png)

###### 4.5.5 关系运算符重载

作用：重载关系运算符，可以让两个自定义类型对象进行对比操作

###### 4.5.6 函数调用运算符重载

- 函数调用运算符`()`也可以重载
- 由于重载后使用的方式非常像函数的调用，因此称为==仿函数==
- 仿函数没有固定写法，非常灵活

##### 4.6 继承

**继承是面向对象三大特性之一（重中之重）**

有些类与类之间存在特殊的关系，如下图：

![image-20210831111422888](https://cdn.jsdelivr.net/gh/Sirwenhao/images/C:%5CUsers%5CWH%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images202108311114004.png)

我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。这个时候我们可以考虑利用继承的技术，减少重复代码。

###### 4.6.1 继承的基本语法

例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同。接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处。

不使用继承写法时：

```c++
//Java页面
class Java 
{
public:
	void header()
	{
		cout << "首页、公开课、登录、注册...（公共头部）" << endl;
	}
	void footer()
	{
		cout << "帮助中心、交流合作、站内地图...(公共底部)" << endl;
	}
	void left()
	{
		cout << "Java,Python,C++...(公共分类列表)" << endl;
	}
	void content()
	{
		cout << "JAVA学科视频" << endl;
	}
};
//Python页面
class Python
{
public:
	void header()
	{
		cout << "首页、公开课、登录、注册...（公共头部）" << endl;
	}
	void footer()
	{
		cout << "帮助中心、交流合作、站内地图...(公共底部)" << endl;
	}
	void left()
	{
		cout << "Java,Python,C++...(公共分类列表)" << endl;
	}
	void content()
	{
		cout << "Python学科视频" << endl;
	}
};
//C++页面
class CPP 
{
public:
	void header()
	{
		cout << "首页、公开课、登录、注册...（公共头部）" << endl;
	}
	void footer()
	{
		cout << "帮助中心、交流合作、站内地图...(公共底部)" << endl;
	}
	void left()
	{
		cout << "Java,Python,C++...(公共分类列表)" << endl;
	}
	void content()
	{
		cout << "C++学科视频" << endl;
	}
};

void test01()
{
	//Java页面
	cout << "Java下载视频页面如下： " << endl;
	Java ja;
	ja.header();
	ja.footer();
	ja.left();
	ja.content();
	cout << "--------------------" << endl;

	//Python页面
	cout << "Python下载视频页面如下： " << endl;
	Python py;
	py.header();
	py.footer();
	py.left();
	py.content();
	cout << "--------------------" << endl;

	//C++页面
	cout << "C++下载视频页面如下： " << endl;
	CPP cp;
	cp.header();
	cp.footer();
	cp.left();
	cp.content();

}

int main() {

	test01();

	system("pause");

	return 0;
}
```

使用继承写法时：

```c++
//公共页面
class BasePage
{
public:
	void header()
	{
		cout << "首页、公开课、登录、注册...（公共头部）" << endl;
	}

	void footer()
	{
		cout << "帮助中心、交流合作、站内地图...(公共底部)" << endl;
	}
	void left()
	{
		cout << "Java,Python,C++...(公共分类列表)" << endl;
	}

};

//Java页面
class Java : public BasePage
{
public:
	void content()
	{
		cout << "JAVA学科视频" << endl;
	}
};
//Python页面
class Python : public BasePage
{
public:
	void content()
	{
		cout << "Python学科视频" << endl;
	}
};
//C++页面
class CPP : public BasePage
{
public:
	void content()
	{
		cout << "C++学科视频" << endl;
	}
};

void test01()
{
	//Java页面
	cout << "Java下载视频页面如下： " << endl;
	Java ja;
	ja.header();
	ja.footer();
	ja.left();
	ja.content();
	cout << "--------------------" << endl;

	//Python页面
	cout << "Python下载视频页面如下： " << endl;
	Python py;
	py.header();
	py.footer();
	py.left();
	py.content();
	cout << "--------------------" << endl;

	//C++页面
	cout << "C++下载视频页面如下： " << endl;
	CPP cp;
	cp.header();
	cp.footer();
	cp.left();
	cp.content();

}

int main()
{
	test01();

	system("pause");

	return 0;
}
```

###### 4.6.2 继承方式

继承的语法：`class 子类：继承方式 父类`

继承的方式：三种

- 公共继承
- 保护继承
- 私有继承

![image-20210901164421323](https://cdn.jsdelivr.net/gh/Sirwenhao/images/C:%5CUsers%5CWH%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images202109011644467.png)

###### 4.6.3 继承中的对象模型

问题：从父类继承过来的成员，那些属于子类对象中？

![image-20210901201758517](https://cdn.jsdelivr.net/gh/Sirwenhao/images/C:%5CUsers%5CWH%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images202109012017703.png)

###### 4.6.4 继承中的构造和析构的顺序

子类继承父类后，当创建子类对象，也会调用父类的构造函数。问题：父类和子类的构造和析构顺序是谁先谁后？

总结：继承中 先调用父类的构造函数，再调用子类构造函数，析构顺序与构造相反

###### 4.6.5 继承同名成员处理方式

问题：当子类与父类出现同名的成员，如何通过子类对象，访问子类或父类中同名的数据呢？

- 访问子类同名成员 直接访问即可
- 访问父类同名成员 需要加作用域

总结：

- 子类对象可以直接访问到子类中同名成员
- 子类对象加作用域可以访问到父类同名成员
- 当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数

###### 4.6.6 继承同名静态成员处理方式

问题：继承中同名的静态成员在子类对象上如何进行访问？静态成员和非静态成员出现同名，处理方式一致

- 访问子类同名成员 直接访问即可
- 访问父类同名成员 需要加作用域

总结：同名静态成员处理方式和非静态成员处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）

###### 4.6.7 多继承语法

C++允许一个类继承多个类

语法：`class 子类：继承方式 父类1，继承方式 父类2...`，多继承可能会引发父类中有同名成员出现，需要加作用域区分。C++实际开发中不建议用多继承。

总结：多继承如果父类中出现了同名情况，子类使用时需要加作用域

###### 4.6.8 菱形继承

菱形继承概念：

- 两个派生类继承同一个基类
- 又有某个类同时继承着两个派生类
- 这种继承被称为菱形继承，或者钻石继承

典型的菱形继承案例：

![image-20210904092234512](https://cdn.jsdelivr.net/gh/Sirwenhao/images/C:%5CUsers%5CWH%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images202109040922656.png)

菱形继承问题：

- 🐏继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性
- 草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以

![image-20210904094642091](https://cdn.jsdelivr.net/gh/Sirwenhao/images/C:%5CUsers%5CWH%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images202109040946325.png)

![image-20210904095014493](https://cdn.jsdelivr.net/gh/Sirwenhao/images/C:%5CUsers%5CWH%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images202109040950638.png)

$vbptr$是指虚基类指针，8和4是指偏移量，此时的`m_Age`只有一个。底层实现的继承是继承的虚拟指针，虚拟指针加上偏移量会指向唯一的数据。

总结：

- 菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义
- 利用虚继承可以说解决菱形继承问题

##### 4.7 多态

![多态](G:\多态.png)

###### 4.7.1 多态的基本概念：多态是C++面向对象的三大特性之一

多态分为两类：

- 静态多态：函数重载 和 运算符重载属于静态多态，复用函数名
- 动态多态：派生类和虚函数实现运行时多态

静态多态和动态多态区别：

- 静态多态的函数地址==早==绑定 - ==编译阶段==确定函数地址
- 动态多态的函数地址==晚==绑定 - ==运行阶段==确定函数地址

总结：

**多态满足条件**：

- 有==继承==关系
- 子类==重写==父类中的虚函数

**多态使用条件：**

- ==父类指针或引用指向子类对象==

重写：==函数返回值类型  函数名  参数列表==  完全一致称为重写

**多态的底层原理：**

```c++
#include<iostream>
using namespace std;

//多态
class Animal
{
public:
	//Speak函数就是虚函数
	//函数前面加上virtual关键字，变为虚函数，那么编译器在编译的时候就不能确定函数调用了
	void speak()   //此处还原成了没有发生多态的情况，此时speak函数为非静态的成员函数，不属于类的对象上，只有非静态的成员变量属于类的对象上。类似于一个空类，空类的大小为一个字节
	{
		cout << "动物在说话" << endl;
	}
};

//猫类
class Cat :public Animal
{
public:
	//重写  函数返回值类型  函数名 参数列表 完全相同。子类重写时virtual关键字可写可不写
	void speak()
	{
		cout << "小猫在说话" << endl;
	}
};

//狗类
class Dog :public Animal
{
public:
	void speak()
	{
		cout << "小狗在说话" << endl;
	}
};
//我们希望传入什么对象，那么就调用什么对象的函数
//如果函数地址在编译阶段就能确定，那么静态多态
//如果函数地址在运行阶段才能确定，就是动态多态

//执行说话的函数
//地址早绑定   在编译阶段确定函数地址
//如果想执行让猫说话，那么这个函数的地址就不能提前绑定，需要在运行阶段进行绑定，即地址晚绑定。具体做法：加关键字virtual
void doSpeak(Animal & animal)//父类的引用在调用子类对象
{
	animal.speak();//此时（）会报错，因为调用的speak并不明确是调用的猫类的还是动物的
}
//多态满足条件
//1、有继承关系.如此例中，猫狗和动物
//2、子类重写父类中的虚函数。如此例中，猫狗重写speak虚函数，区别于函数重载
//多态使用：
//父类指针或引用指向子类对象

void test01()
{
	Cat cat;//Animal & animal = cat;如果不使用地址晚绑定的话，此处现实的就应该是动物在说话
	doSpeak(cat);

	Dog dog;
	doSpeak(dog);
}

void test02()
{
	cout << "size of Animal = " << sizeof(Animal) << endl;
}

int main()
{
	//test01();
	test02(); //不加virtual关键字时，此处结果为1（1个字节）；加上virtual关键字后，此处结果为4（4个字节）.

	system("pause");

	return 0;
}
```

`Tips`：**空类**的大小占**一个字节**。无论是几级的**指针**，什么类型的指针都占**四个字节**。

![image-20210906211346143](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210906211346143.png)

![image-20210906212203640](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210906212203640.png)

![image-20210906212741351](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210906212741351.png)

​		动态多态的原理：由于写了虚函数，==类的内部的结构改变，多了一个虚函数表指针==，这个指针指向一个虚函数表，==虚函数表内部存储的是虚函数的函数入口的地址==；当子类重写了父类的虚函数的时候，他会把自身的虚函数表中的函数入口地址给替换掉（原来存放的是父类的），替换为子类的函数入口地址。因此，当使用父类的引用指向子类对象的时候，由于本身还是一个子类对象，所以当调用公共的`speak`接口时，他会从子类中去找入口地址。

使用开发人员命令提示工具做验证：

不写`virtual`关键字时：对应空类的那种情况

![image-20210906213922558](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210906213922558.png)

加上关键字`virtual`之后

![image-20210906214055125](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210906214055125.png)

当子类没有发生重写时：

![image-20210906214744146](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210906214744146.png)

当子类发生重写时：`Cat`重写

![image-20210906215023110](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210906215023110.png)

###### 4.7.2 多态案例——计算器类

案例描述：分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类

多态的优点：

- 代码组织结构清晰
- 可读性强
- 利用前期和后期的扩展以及维护

```C++
#include<iostream>
#include<string>
using namespace std;

//分别利用普通的写法和多态技术实现计算器

//普通写法

class Calculator 
{
public:

	int getResult(string oper)
	{
		if (oper == "+")
		{
			return m_Num1 + m_Num2;
		}
		else if (oper == "-")
		{
			return m_Num1 - m_Num2;
		}
		else if (oper == "*")
		{
			return m_Num1 * m_Num2;
		}
		//如果想扩展新的功能，需要修改源码
		//在真实开发中  提倡  开闭原则
		//开闭原则：对扩展进行开放，对修改进行关闭
	}

	int m_Num1;//操作数1
	int m_Num2;//操作数2
};

void test01()
{
	//创建计算器对象
	Calculator c;
	c.m_Num1 = 10;
	c.m_Num2 = 10;

	cout << c.m_Num1 << " + " << c.m_Num2 << " = " << c.getResult("+") << endl;

	cout << c.m_Num1 << " - " << c.m_Num2 << " = " << c.getResult("-") << endl;

	cout << c.m_Num1 << " * " << c.m_Num2 << " = " << c.getResult("*") << endl;
}

//利用多态实现计算器
//多态的优势：1、组织结构清晰 2、可读性强 3、对于前期和后期的拓展以及维护性高
//实现计算器的抽象类

class AbstractCalculator 
{
public:

	virtual int getResult()
	{
		return 0;
	}

	int m_Num1;
	int m_Num2;

};

//加法计算器类
class AddCalculator :public AbstractCalculator
{
public:

	int getResult()
	{
		return m_Num1 + m_Num2;
	}
};

//减法计算器类
class SubCalculator :public AbstractCalculator
{
public:

	int getResult()
	{
		return m_Num1 - m_Num2;
	}
};

//乘法计算器类
class MultiCalculator :public AbstractCalculator
{
public:

	int getResult()
	{
		return m_Num1 * m_Num2;
	}
};

void test02()
{
	//多态使用条件
	//父类的指针或者引用指向子类对象

	//加法运算
	AbstractCalculator* abc = new AddCalculator;
	abc->m_Num1 = 10;
	abc->m_Num2 = 20;

	cout << abc->m_Num1 << " + " << abc->m_Num2 << " = " << abc->getResult() << endl;

	//new的数据存储在堆区，用完需要删除
	delete abc;

	//减法运算
	abc = new SubCalculator;
	abc->m_Num1 = 30;
	abc->m_Num2 = 20;

	cout << abc->m_Num1 << " - " << abc->m_Num2 << " = " << abc->getResult() << endl;
	delete abc;

	//乘法运算
	abc = new MultiCalculator;
	abc->m_Num1 = 30;
	abc->m_Num2 = 20;

	cout << abc->m_Num1 << " * " << abc->m_Num2 << " = " << abc->getResult() << endl;
	delete abc;
}

int main()
{
	//test01();

	test02();

	system("pause");

	return 0;
}

```

总结：C++开发提倡利用多态设计程序框架，因为多态优点很多

###### 4.7.3 纯虚函数和抽象类

在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容。因此可以将虚函数改为纯虚函数，纯虚函数的语法：

```c++
virtual 返回值类型 函数名 （参数列表）= 0;
```

当类中有了纯虚函数，这个类也成为抽象类

抽象类特点：

- 无法实例化对象
- 子类必须重写抽象类中的纯虚函数，否则也属于抽象类

###### 4.7.4 多态案例二-制作饮品

案例描述：制作饮品的大致流程为：煮水 - 冲泡 - 倒入杯中 - 加入辅料。利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶。

```c++
#include<iostream>
using namespace std;

//多态案例2 制作饮品
class AbstractDrinking 
{
public:
	//煮水
	virtual void Boil() = 0;

	//冲泡
	virtual void Brew() = 0;

	//倒入杯中
	virtual void PourInCup() = 0;

	//加入辅料
	virtual void AddSomething() = 0;

	//制作饮品
	void makeDrink()
	{
		Boil();
		Brew();
		PourInCup();
		AddSomething();
	}
};

//制作咖啡
class Coffee :public AbstractDrinking
{
public:
	//煮水
	virtual void Boil()
	{
		cout << "煮农夫山泉" << endl;
	}

	//冲泡
	virtual void Brew()
	{
		cout << "冲泡咖啡" << endl;
	}

	//倒入杯中
	virtual void PourInCup()
	{
		cout << "倒入杯中" << endl;
	}

	//加入辅料
	virtual void AddSomething()
	{
		cout << "加糖和牛奶" << endl;
	}
};

//制作茶叶
class Tea :public AbstractDrinking
{
public:
	//煮水
	virtual void Boil()
	{
		cout << "煮依云" << endl;
	}

	//冲泡
	virtual void Brew()
	{
		cout << "冲泡茶叶" << endl;
	}

	//倒入杯中
	virtual void PourInCup()
	{
		cout << "倒入杯中" << endl;
	}

	//加入辅料
	virtual void AddSomething()
	{
		cout << "加柠檬" << endl;
	}
};

//制作函数
void doWork(AbstractDrinking *abs)
{
	abs->makeDrink();
	delete abs;//堆区的数据手动开辟，需要手动释放
}

void test01()
{
	//制作咖啡
	doWork(new Coffee);//AbstractDrinking *abs = new Coffee

	cout << "-----------------------" << endl;

	doWork(new Tea);//AbstractDrinking *abs = new Tea
}

int main()
{
	test01();

	system("pause");

	return 0;
}
```

###### 4.7.5 虚析构和纯虚析构

多态使用时，如果子类中有属性开辟到==堆区==，那么==父类指针在释放时无法调用子类的析构代码==。解决方式：将父类中的析构函数改为虚析构或者纯虚析构。

虚析构和纯虚析构共性：

- 可以解决父类指针释放子类对象的问题
- 都需要有具体的函数实现

虚析构和纯虚析构的区别：

- 如果是纯虚析构，该类属于抽象类，无法实例化对象

虚析构语法：

```c++
virtual ~类名（）{}
```

纯虚析构语法：

```c++
virtual ~类名（）= 0；

类名::~类名（）{}
```

```C++
#include<iostream>
#include<string>
using namespace std;

//虚析构和纯虚析构

class Animal 
{
public:

	Animal()
	{
		cout << "Animal的构造函数调用" << endl;
	}

	~Animal()
	{
		cout << "Animal的析构函数调用" << endl;
	}

	//纯虚函数
	virtual void speak() = 0;
};

class Cat :public Animal
{
public:

	Cat(string name)
	{
		cout << "Cat构造函数调用" << endl;
		m_Name = new string(name);
	}

	virtual void speak()
	{
		cout << *m_Name << "小猫在说话" << endl;
	}

	~Cat()
	{
		if (m_Name != NULL)
		{
			cout << "Cat的析构函数调用" << endl;
			delete m_Name;
			m_Name = NULL;
		}
	}

	string *m_Name;

};

void test01()
{
	Animal* animal = new Cat("Tom");
	animal->speak();
	delete animal;
}

int main()
{
	test01();

	system("pause");

	return 0;
}
```

上述程序输出为：

![image-20210909205352036](C:\Users\WH\AppData\Roaming\Typora\typora-user-images\image-20210909205352036.png)

没走`Cat`的析构函数，正常的调用顺序应该是构造函数：父类—>子类；析构函数：子类—>父类，但是此处没有走`Cat`析构函数调用，说明堆区的数据没有释放干净，导致内存泄漏

```c++
#include<iostream>
#include<string>
using namespace std;

//虚析构和纯虚析构

class Animal 
{
public:

	Animal()
	{
		cout << "Animal的构造函数调用" << endl;
	}

	////利用虚析构可以解决 父类指针释放子类对象时不干净的问题
	//virtual ~Animal()//析构改为虚析构
	//{
	//	cout << "Animal的虚析构函数调用" << endl;
	//}

	//纯虚析构
	virtual ~Animal() = 0;//纯虚析构的声明（需要声明也需要实现），有了纯虚析构之后，这个类也属于抽象类，无法实例化对象

	//纯虚函数
	virtual void speak() = 0;
};

Animal::~Animal() //纯虚析构的具体实现
{
	cout << "Animal的纯虚析构函数调用" << endl;
}

class Cat :public Animal
{
public:

	Cat(string name)
	{
		cout << "Cat构造函数调用" << endl;
		m_Name = new string(name);
	}

	virtual void speak()
	{
		cout << *m_Name << "小猫在说话" << endl;
	}

	~Cat()
	{
		if (m_Name != NULL)
		{
			cout << "Cat的析构函数调用" << endl;
			delete m_Name;
			m_Name = NULL;
		}
	}

	string *m_Name;

};

void test01()
{
	Animal* animal = new Cat("Tom");
	animal->speak();
	//父类指针在析构时候，不会调用子类中析构函数，导致子类如果有堆区属性，出现内存泄露
	//解决办法：就是把析构改为虚析构
	delete animal;
}

int main()
{
	test01();

	system("pause");

	return 0;
}
```

总结：

- 如果只写了虚析构，没有纯虚函数的情况下，还是可以实例化对象的
- 拥有纯虚析构的类也属于抽象类，则一定不能实例化对象
- 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象
- 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构

###### 4.7.6 多态案例三 - 电脑组装

案例描述：

​		电脑主要组成部件为`CPU`（用于计算），显卡（用于显示），内存条（用于存储）。将每个零件封装出抽象类，并且提供不同的厂商生产不同的零件，例如`Intel`厂商和`Lenovo`厂商，创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口，测试时组装三台不同的电脑进行工作。

```C++
#include<iostream>
using namespace std;

//抽象不同的零件类
//抽象CPU类
class CPU
{
public:
	
	//抽象的计算函数
	virtual void calculate() = 0;
};

//抽象显卡类
class VideoCard
{
public:

	//抽象的显示函数
	virtual void display() = 0;
};

//抽象内存类
class Memory
{
public:

	//抽象的显示函数
	virtual void storage() = 0;
};

//电脑类
class Computer
{
public:
	Computer(CPU* cpu, VideoCard* vc, Memory* mem)
	{
		m_cpu = cpu;
		m_vc = vc;
		m_mem = mem;
	}

	//提供工作的函数
	void work()
	{
		//让零件工作，调用其接口
		m_cpu->calculate();

		m_vc->display();

		m_mem->storage();

	}

	//提供一个析构函数释放三个电脑零件
	~Computer()
	{
		//释放CPU零件
		if (m_cpu != NULL)
		{
			delete m_cpu;
			m_cpu = NULL;
		}

		//释放显卡零件
		if (m_vc != NULL)
		{
			delete m_vc;
			m_vc = NULL;
		}

		//释放存储零件
		if(m_mem != NULL)
		{
			delete m_mem;
			m_mem = NULL;
		}
	}

private:

	CPU* m_cpu;//CPU的零件指针
	VideoCard* m_vc;//显卡零件指针
	Memory* m_mem;//内存条零件指针

};

//封装成具体的厂商
//Intel厂商
class IntelCPU:public CPU
{
public:
	virtual void calculate()
	{
		cout << "Intel的CPU开始计算了~！" << endl;
	}
};

class IntelVideoCard :public VideoCard
{
public:
	virtual void display()
	{
		cout << "Intel的显卡开始显示了~！" << endl;
	}
};

class IntelMemory :public Memory
{
public:
	virtual void storage()
	{
		cout << "Intel的显卡开始存储了~！" << endl;
	}
};


//Lenovo厂商
class LenovoCPU :public CPU
{
public:
	virtual void calculate()
	{
		cout << "Lenovo的CPU开始计算了~！" << endl;
	}
};

class LenovoVideoCard :public VideoCard
{
public:
	virtual void display()
	{
		cout << "Lenovo的显卡开始显示了~！" << endl;
	}
};

class LenovoMemory :public Memory
{
public:
	virtual void storage()
	{
		cout << "Lenovo的显卡开始存储了~！" << endl;
	}
};

void test01()
{
	//第一台电脑的零件
	CPU* intelCpu = new IntelCPU;
	VideoCard* intelVideoCard = new IntelVideoCard;
	Memory* intelMemory = new IntelMemory;

	cout << "第一台电脑开始工作" << endl;
	//创建第一台电脑
	Computer* computer1 = new Computer(intelCpu, intelVideoCard, intelMemory);
	computer1->work();
	delete computer1;

	cout << "------------------------" << endl;
	cout << "第二台电脑开始工作" << endl;
	//创建第二台电脑
	Computer* computer2 = new Computer(new LenovoCPU, new LenovoVideoCard, new LenovoMemory);
	computer2->work();
	delete computer2;

	cout << "-----------------------" << endl;
	cout << "第三台电脑开始工作：" << endl;
	//第三台电脑组装
	Computer* computer3 = new Computer(new LenovoCPU, new IntelVideoCard, new LenovoMemory);;
	computer3->work();
	delete computer3;
}

int main()
{
	test01();

	system("pause");

	return 0;
}
```

#### 5 文件操作

​		程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放。通过==**文件可以将数据持久化**==，C++中对文件操作需要包含头文件`<fstream>`

文件类型分为两种：

- **文本文件**     -  文件以文本的==`ASCII码`==形式存储在计算机中
- **二进制文件**  - 文件以文本==二进制==形式存储在计算机中，用户一般不能直接读懂他们

操作文件的三大类：

- `ofstream`：写操作
- `ifstream`：读操作
- `fstream`：读写操作

##### 5.1 文本文件

###### 5.1.1 写文件

步骤如下：

- 1、包含头文件`#include<fstream>`
- 2、创建流对象`ofstream ofs;`
- 3、打开文件`ofs.open("文件路径"，打开方式)`
- 4、写数据`ofs<<"写入的数据";`
- 5、关闭文件`ofs.close();`

文件打开方式：

| 打开方式       | 解释                       |
| -------------- | -------------------------- |
| ==`ios::in`==  | 为读文件而打开文件         |
| ==`ios::out`== | 为写文件而打开文件         |
| `ios::ate`     | 初始位置：文件尾           |
| `ios::app`     | 追加方式写文件             |
| `ios::trunc`   | 如果文件存在先删除，再创建 |
| `ios::binary`  | 二进制方式                 |

注意：**文件打开方式可以配合使用，利用`|`操作符**

```C++
#include<iostream>
using namespace std;
#include<fstream>//头文件包含


//文本文件 写文件



void test01()
{
	//1、包含头文件 fstream

	//2、创建流对象

	ofstream ofs;

	//3、指定打开方式
	ofs.open("test.txt", ios::out);//默认情况下txt所保存的目录和当前的程序目录一致

	//4、写内容
	ofs << "姓名：张三" << endl;
	ofs << "性别：男" << endl;
	ofs << "年龄：18" << endl;

	//5、关闭文件
	ofs.close();

}

int main()
{
	test01();

	system("pause");

	return 0;
}
```

总结：

- 文件操作必须包含头文件`fstream`
- 读文件可以利用`ofstream`或者`fstream`类
- 打开文件时候需要指定操作文件的路径，以及打开方式
- 利用`<<`可以向文件中写数据
- 操作完毕，要关闭文件

###### 5.1.2 读文件

读文件与写文件步骤相似，但是读取方式相对比较多。读文件步骤如下：

- 1、包含头文件`#include<fstream>`
- 2、创建流对象`ifstream ifs;`
- 3、打开文件并判断文件是否打开成功`ifs.open("文件路径",打开方式)`
- 4、读数据，四种读取方式
- 5、关闭文件`ifs.close();`

```C++
#include<iostream>
#include<fstream>
#include<string>
using namespace std;

//文本文件 读文件
void test01()
{
	//1、包含头文件

	//2、创建流对象
	ifstream ifs;

	//3、打开文件  并且判断是否打开成功
	ifs.open("test.txt", ios::in);
	if (!ifs.is_open())
	{
		cout << "文件打开失败" << endl;
		return;
	}

	//4、读数据(四种方法)
	
	//第一种:
	char buff[1024] = { 0 };//创建权威0的字符数组
	while (ifs >> buff)//利用右移运算符读数据，读到头返回一个假的标记，然后退出while循环
	{
		cout << buff << endl;
	}

	////第二种
	//char buff[1024] = {0};
	//while (ifs.getline(buff, sizeof(buff)))//两个参数一个是字符串首地址，一个是字符串长
	//{
	//	cout << buff << endl;
	//}

	////第三种
	//string buff;
	//while (getline(ifs, buff))
	//{
	//	cout << buff << endl;
	//}

	////第四种(把文件中的字符一个个读取)，不推荐速度慢
	//char c;
	//while ((c = ifs.get()) != EOF)//EOF(end of file)作为是否读取到文件尾的判断标志
	//{
	//	cout << c;
	//}

	//5、关闭文件
	ifs.close();
}

int main()
{
	test01();

	system("pause");

	return 0;
}
```

`Tips：`一开始读取创建好的`txt`文件时，读取出来是乱码，因为`txt`文件的编码方式是`UTF-8`，修改为`ANSI`格式即可。（`ANSI编码一般指Windows-1252编码，是一个256个字符的字集的编码，每个字符由一个字节表示。其中前128个字符(00-7F)和ASCII的7bits编码一样，后128个字符中有一些欧洲国家用的有重音的字符。ANSI编码在不同语言的Windows下也指此语言下的Windows编码页，比如中文环境下指Windows-936(也就是GB2312)，日文环境下是Windows-932(JIS)编码等等，也是前128个字符(00-7F)和ASCII的7bits编码一样，其他字符则由2个字节表示。UTF-8是针对Unicode的可变长度字符编码，一个字符可以由1到4个字节表示，其中由一个字节表示的字符和ASCII的7bits编码一样，而包括中文在内的大部分字符则由3个字节表示。`）

总结：

- 读文件可以利用`ifstream`，或者`fstream`类
- 利用`is_open`函数可以判断文件是否打开成功
- `close`关闭文件

##### 5.2 二进制文件

​		以二进制的方式对文件进行读写操作，打开方式要指定为：`ios::binary`

###### 5.2.1 写文件

​		二进制方式写文件主要利用流对象调用成员函数`write`，函数原型：`ostream &write(const char*buffer,int len);`。参数解释：字符指针`buffer`指向内存中一段存储空间，`len`是读写的字节数

```c++
#include<iostream>
#include<fstream>
using namespace std;

//二进制文件 写文件
class Person 
{
public:
	char m_Name[64];//姓名
	int m_Age;//年龄
};

void test01()
{
	//1、包含头文件

	//2、创建流对象
	ofstream ofs;

	//3、打开文件
	ofs.open("person.txt",ios::out | ios::binary);//中间加操作符 |

	//4、写文件
	Person p = { "张三", 18 };
	ofs.write((const char*)&p,sizeof(Person));

	//5、关闭文件
	ofs.close();
}

int main()
{
	test01();
	system("pause");
	return 0;
}
```

总结：

- 文件输出流对象可以通过`write`函数，以二进制方式写数据

###### 5.2.2 读文件

​		二进制方式读文件主要利用流对象调用成员函数`read`，函数原型：`istream &read(char *buffer,int len);`。参数解释：字符指针`buffer`指向内存中一段存储空间，`len`是读写的字节数

```c++
#include<iostream>
#include<fstream>
using namespace std;

class Person 
{
public:
	char m_Name[64];
	int m_Age;
};

//二进制文件 读文件
void test01()
{
	//1、包含头文件
	//2、创建流对象
	ifstream ifs;

	//3、打开文件 判断文件是否打开成功
	ifs.open("Person.txt",ios::in | ios::binary);
	if (!ifs.is_open())
	{
		cout << "文件打开失败" << endl;
		return;
	}

	//4、读文件
	Person p;

	ifs.read((char*)&p, sizeof(Person));

	cout << "姓名：" << p.m_Name << "  年龄:" << p.m_Age << endl;

	//5、关闭文件
	ifs.close();
}

int main()
{
	test01();
	system("pause");
	return 0;
}
```

总结：

- 文件输入流对象 可以通过`read`函数，以二进制方式读数据

